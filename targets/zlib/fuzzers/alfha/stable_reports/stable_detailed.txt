/home/minseo/alfha/targets/zlib/target/adler32.c:
    1|       |/* adler32.c -- compute the Adler-32 checksum of a data stream
    2|       | * Copyright (C) 1995-2011, 2016 Mark Adler
    3|       | * For conditions of distribution and use, see copyright notice in zlib.h
    4|       | */
    5|       |
    6|       |/* @(#) $Id$ */
    7|       |
    8|       |#include "zutil.h"
    9|       |
   10|   291M|#define BASE 65521U     /* largest prime smaller than 65536 */
   11|  71.8M|#define NMAX 5552
   12|       |/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
   13|       |
   14|   113G|#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
   15|  56.8G|#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
   16|  28.4G|#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
   17|  14.2G|#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
   18|  7.10G|#define DO16(buf)   DO8(buf,0); DO8(buf,8);
   19|       |
   20|       |/* use NO_DIVIDE if your processor does not do division in hardware --
   21|       |   try it both ways to see which is faster */
   22|       |#ifdef NO_DIVIDE
   23|       |/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
   24|       |   (thank you to John Reiser for pointing this out) */
   25|       |#  define CHOP(a) \
   26|       |    do { \
   27|       |        unsigned long tmp = a >> 16; \
   28|       |        a &= 0xffffUL; \
   29|       |        a += (tmp << 4) - tmp; \
   30|       |    } while (0)
   31|       |#  define MOD28(a) \
   32|       |    do { \
   33|       |        CHOP(a); \
   34|       |        if (a >= BASE) a -= BASE; \
   35|       |    } while (0)
   36|       |#  define MOD(a) \
   37|       |    do { \
   38|       |        CHOP(a); \
   39|       |        MOD28(a); \
   40|       |    } while (0)
   41|       |#  define MOD63(a) \
   42|       |    do { /* this assumes a is not negative */ \
   43|       |        z_off64_t tmp = a >> 32; \
   44|       |        a &= 0xffffffffL; \
   45|       |        a += (tmp << 8) - (tmp << 5) + tmp; \
   46|       |        tmp = a >> 16; \
   47|       |        a &= 0xffffL; \
   48|       |        a += (tmp << 4) - tmp; \
   49|       |        tmp = a >> 16; \
   50|       |        a &= 0xffffL; \
   51|       |        a += (tmp << 4) - tmp; \
   52|       |        if (a >= BASE) a -= BASE; \
   53|       |    } while (0)
   54|       |#else
   55|   143M|#  define MOD(a) a %= BASE
   56|  67.2M|#  define MOD28(a) a %= BASE
   57|      0|#  define MOD63(a) a %= BASE
   58|       |#endif
   59|       |
   60|       |/* ========================================================================= */
   61|   362M|uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {
   62|   362M|    unsigned long sum2;
   63|   362M|    unsigned n;
   64|       |
   65|       |    /* split Adler-32 into component sums */
   66|   362M|    sum2 = (adler >> 16) & 0xffff;
   67|   362M|    adler &= 0xffff;
   68|       |
   69|       |    /* in case user likes doing a byte at a time, keep it fast */
   70|   362M|    if (len == 1) {
  ------------------
  |  Branch (70:9): [True: 6.47M, False: 355M]
  ------------------
   71|  6.47M|        adler += buf[0];
   72|  6.47M|        if (adler >= BASE)
  ------------------
  |  Branch (72:13): [True: 36, False: 6.47M]
  ------------------
   73|     36|            adler -= BASE;
   74|  6.47M|        sum2 += adler;
   75|  6.47M|        if (sum2 >= BASE)
  ------------------
  |  Branch (75:13): [True: 34.8k, False: 6.44M]
  ------------------
   76|  34.8k|            sum2 -= BASE;
   77|  6.47M|        return adler | (sum2 << 16);
   78|  6.47M|    }
   79|       |
   80|       |    /* initial Adler-32 value (deferred check for len == 1 speed) */
   81|   355M|    if (buf == Z_NULL)
  ------------------
  |  Branch (81:9): [True: 216M, False: 139M]
  ------------------
   82|   216M|        return 1L;
   83|       |
   84|       |    /* in case short lengths are provided, keep it somewhat fast */
   85|   139M|    if (len < 16) {
  ------------------
  |  Branch (85:9): [True: 67.2M, False: 71.8M]
  ------------------
   86|   561M|        while (len--) {
  ------------------
  |  Branch (86:16): [True: 494M, False: 67.2M]
  ------------------
   87|   494M|            adler += *buf++;
   88|   494M|            sum2 += adler;
   89|   494M|        }
   90|  67.2M|        if (adler >= BASE)
  ------------------
  |  Branch (90:13): [True: 5.45k, False: 67.1M]
  ------------------
   91|  5.45k|            adler -= BASE;
   92|  67.2M|        MOD28(sum2);            /* only added so many BASE's */
   93|  67.2M|        return adler | (sum2 << 16);
   94|  67.2M|    }
   95|       |
   96|       |    /* do length NMAX blocks -- requires just one modulo operation */
   97|  71.8M|    while (len >= NMAX) {
  ------------------
  |  Branch (97:12): [True: 0, False: 71.8M]
  ------------------
   98|      0|        len -= NMAX;
   99|      0|        n = NMAX / 16;          /* NMAX is divisible by 16 */
  100|      0|        do {
  101|      0|            DO16(buf);          /* 16 sums unrolled */
  102|      0|            buf += 16;
  103|      0|        } while (--n);
  ------------------
  |  Branch (103:18): [True: 0, False: 0]
  ------------------
  104|      0|        MOD(adler);
  105|      0|        MOD(sum2);
  106|      0|    }
  107|       |
  108|       |    /* do remaining bytes (less than NMAX, still just one modulo) */
  109|  71.8M|    if (len) {                  /* avoid modulos if none remaining */
  ------------------
  |  Branch (109:9): [True: 71.8M, False: 0]
  ------------------
  110|  7.17G|        while (len >= 16) {
  ------------------
  |  Branch (110:16): [True: 7.10G, False: 71.8M]
  ------------------
  111|  7.10G|            len -= 16;
  112|  7.10G|            DO16(buf);
  113|  7.10G|            buf += 16;
  114|  7.10G|        }
  115|   313M|        while (len--) {
  ------------------
  |  Branch (115:16): [True: 241M, False: 71.8M]
  ------------------
  116|   241M|            adler += *buf++;
  117|   241M|            sum2 += adler;
  118|   241M|        }
  119|  71.8M|        MOD(adler);
  120|  71.8M|        MOD(sum2);
  121|  71.8M|    }
  122|       |
  123|       |    /* return recombined sums */
  124|  71.8M|    return adler | (sum2 << 16);
  125|   139M|}
  126|       |
  127|       |/* ========================================================================= */
  128|   362M|uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len) {
  129|   362M|    return adler32_z(adler, buf, len);
  130|   362M|}
  131|       |
  132|       |/* ========================================================================= */
  133|      0|local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {
  134|      0|    unsigned long sum1;
  135|      0|    unsigned long sum2;
  136|      0|    unsigned rem;
  137|       |
  138|       |    /* for negative len, return invalid adler32 as a clue for debugging */
  139|      0|    if (len2 < 0)
  ------------------
  |  Branch (139:9): [True: 0, False: 0]
  ------------------
  140|      0|        return 0xffffffffUL;
  141|       |
  142|       |    /* the derivation of this formula is left as an exercise for the reader */
  143|      0|    MOD63(len2);                /* assumes len2 >= 0 */
  144|      0|    rem = (unsigned)len2;
  145|      0|    sum1 = adler1 & 0xffff;
  146|      0|    sum2 = rem * sum1;
  147|      0|    MOD(sum2);
  148|      0|    sum1 += (adler2 & 0xffff) + BASE - 1;
  149|      0|    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
  150|      0|    if (sum1 >= BASE) sum1 -= BASE;
  ------------------
  |  Branch (150:9): [True: 0, False: 0]
  ------------------
  151|      0|    if (sum1 >= BASE) sum1 -= BASE;
  ------------------
  |  Branch (151:9): [True: 0, False: 0]
  ------------------
  152|      0|    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
  ------------------
  |  Branch (152:9): [True: 0, False: 0]
  ------------------
  153|      0|    if (sum2 >= BASE) sum2 -= BASE;
  ------------------
  |  Branch (153:9): [True: 0, False: 0]
  ------------------
  154|      0|    return sum1 | (sum2 << 16);
  155|      0|}
  156|       |
  157|       |/* ========================================================================= */
  158|      0|uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2, z_off_t len2) {
  159|      0|    return adler32_combine_(adler1, adler2, len2);
  160|      0|}
  161|       |
  162|      0|uLong ZEXPORT adler32_combine64(uLong adler1, uLong adler2, z_off64_t len2) {
  163|      0|    return adler32_combine_(adler1, adler2, len2);
  164|      0|}

/home/minseo/alfha/targets/zlib/target/crc32.c:
    1|       |/* crc32.c -- compute the CRC-32 of a data stream
    2|       | * Copyright (C) 1995-2022 Mark Adler
    3|       | * For conditions of distribution and use, see copyright notice in zlib.h
    4|       | *
    5|       | * This interleaved implementation of a CRC makes use of pipelined multiple
    6|       | * arithmetic-logic units, commonly found in modern CPU cores. It is due to
    7|       | * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.
    8|       | */
    9|       |
   10|       |/* @(#) $Id$ */
   11|       |
   12|       |/*
   13|       |  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
   14|       |  protection on the static variables used to control the first-use generation
   15|       |  of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should
   16|       |  first call get_crc_table() to initialize the tables before allowing more than
   17|       |  one thread to use crc32().
   18|       |
   19|       |  MAKECRCH can be #defined to write out crc32.h. A main() routine is also
   20|       |  produced, so that this one source file can be compiled to an executable.
   21|       | */
   22|       |
   23|       |#ifdef MAKECRCH
   24|       |#  include <stdio.h>
   25|       |#  ifndef DYNAMIC_CRC_TABLE
   26|       |#    define DYNAMIC_CRC_TABLE
   27|       |#  endif /* !DYNAMIC_CRC_TABLE */
   28|       |#endif /* MAKECRCH */
   29|       |
   30|       |#include "zutil.h"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */
   31|       |
   32|       | /*
   33|       |  A CRC of a message is computed on N braids of words in the message, where
   34|       |  each word consists of W bytes (4 or 8). If N is 3, for example, then three
   35|       |  running sparse CRCs are calculated respectively on each braid, at these
   36|       |  indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...
   37|       |  This is done starting at a word boundary, and continues until as many blocks
   38|       |  of N * W bytes as are available have been processed. The results are combined
   39|       |  into a single CRC at the end. For this code, N must be in the range 1..6 and
   40|       |  W must be 4 or 8. The upper limit on N can be increased if desired by adding
   41|       |  more #if blocks, extending the patterns apparent in the code. In addition,
   42|       |  crc32.h would need to be regenerated, if the maximum N value is increased.
   43|       |
   44|       |  N and W are chosen empirically by benchmarking the execution time on a given
   45|       |  processor. The choices for N and W below were based on testing on Intel Kaby
   46|       |  Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64
   47|       |  Octeon II processors. The Intel, AMD, and ARM processors were all fastest
   48|       |  with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.
   49|       |  They were all tested with either gcc or clang, all using the -O3 optimization
   50|       |  level. Your mileage may vary.
   51|       | */
   52|       |
   53|       |/* Define N */
   54|       |#ifdef Z_TESTN
   55|       |#  define N Z_TESTN
   56|       |#else
   57|      0|#  define N 5
   58|       |#endif
   59|       |#if N < 1 || N > 6
   60|       |#  error N must be in 1..6
   61|       |#endif
   62|       |
   63|       |/*
   64|       |  z_crc_t must be at least 32 bits. z_word_t must be at least as long as
   65|       |  z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and
   66|       |  that bytes are eight bits.
   67|       | */
   68|       |
   69|       |/*
   70|       |  Define W and the associated z_word_t type. If W is not defined, then a
   71|       |  braided calculation is not used, and the associated tables and code are not
   72|       |  compiled.
   73|       | */
   74|       |#ifdef Z_TESTW
   75|       |#  if Z_TESTW-1 != -1
   76|       |#    define W Z_TESTW
   77|       |#  endif
   78|       |#else
   79|       |#  ifdef MAKECRCH
   80|       |#    define W 8         /* required for MAKECRCH */
   81|       |#  else
   82|       |#    if defined(__x86_64__) || defined(__aarch64__)
   83|      0|#      define W 8
   84|       |#    else
   85|       |#      define W 4
   86|       |#    endif
   87|       |#  endif
   88|       |#endif
   89|       |#ifdef W
   90|       |#  if W == 8 && defined(Z_U8)
   91|       |     typedef Z_U8 z_word_t;
   92|       |#  elif defined(Z_U4)
   93|       |#    undef W
   94|       |#    define W 4
   95|       |     typedef Z_U4 z_word_t;
   96|       |#  else
   97|       |#    undef W
   98|       |#  endif
   99|       |#endif
  100|       |
  101|       |/* If available, use the ARM processor CRC32 instruction. */
  102|       |#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8
  103|       |#  define ARMCRC32
  104|       |#endif
  105|       |
  106|       |#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
  107|       |/*
  108|       |  Swap the bytes in a z_word_t to convert between little and big endian. Any
  109|       |  self-respecting compiler will optimize this to a single machine byte-swap
  110|       |  instruction, if one is available. This assumes that word_t is either 32 bits
  111|       |  or 64 bits.
  112|       | */
  113|      0|local z_word_t byte_swap(z_word_t word) {
  114|      0|#  if W == 8
  115|      0|    return
  116|      0|        (word & 0xff00000000000000) >> 56 |
  117|      0|        (word & 0xff000000000000) >> 40 |
  118|      0|        (word & 0xff0000000000) >> 24 |
  119|      0|        (word & 0xff00000000) >> 8 |
  120|      0|        (word & 0xff000000) << 8 |
  121|      0|        (word & 0xff0000) << 24 |
  122|      0|        (word & 0xff00) << 40 |
  123|      0|        (word & 0xff) << 56;
  124|       |#  else   /* W == 4 */
  125|       |    return
  126|       |        (word & 0xff000000) >> 24 |
  127|       |        (word & 0xff0000) >> 8 |
  128|       |        (word & 0xff00) << 8 |
  129|       |        (word & 0xff) << 24;
  130|       |#  endif
  131|      0|}
  132|       |#endif
  133|       |
  134|       |#ifdef DYNAMIC_CRC_TABLE
  135|       |/* =========================================================================
  136|       | * Table of powers of x for combining CRC-32s, filled in by make_crc_table()
  137|       | * below.
  138|       | */
  139|       |   local z_crc_t FAR x2n_table[32];
  140|       |#else
  141|       |/* =========================================================================
  142|       | * Tables for byte-wise and braided CRC-32 calculations, and a table of powers
  143|       | * of x for combining CRC-32s, all made by make_crc_table().
  144|       | */
  145|       |#  include "crc32.h"
  146|       |#endif
  147|       |
  148|       |/* CRC polynomial. */
  149|      0|#define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */
  150|       |
  151|       |/*
  152|       |  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,
  153|       |  reflected. For speed, this requires that a not be zero.
  154|       | */
  155|      0|local z_crc_t multmodp(z_crc_t a, z_crc_t b) {
  156|      0|    z_crc_t m, p;
  157|       |
  158|      0|    m = (z_crc_t)1 << 31;
  159|      0|    p = 0;
  160|      0|    for (;;) {
  161|      0|        if (a & m) {
  ------------------
  |  Branch (161:13): [True: 0, False: 0]
  ------------------
  162|      0|            p ^= b;
  163|      0|            if ((a & (m - 1)) == 0)
  ------------------
  |  Branch (163:17): [True: 0, False: 0]
  ------------------
  164|      0|                break;
  165|      0|        }
  166|      0|        m >>= 1;
  167|      0|        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
  ------------------
  |  Branch (167:13): [True: 0, False: 0]
  ------------------
  168|      0|    }
  169|      0|    return p;
  170|      0|}
  171|       |
  172|       |/*
  173|       |  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been
  174|       |  initialized.
  175|       | */
  176|      0|local z_crc_t x2nmodp(z_off64_t n, unsigned k) {
  177|      0|    z_crc_t p;
  178|       |
  179|      0|    p = (z_crc_t)1 << 31;           /* x^0 == 1 */
  180|      0|    while (n) {
  ------------------
  |  Branch (180:12): [True: 0, False: 0]
  ------------------
  181|      0|        if (n & 1)
  ------------------
  |  Branch (181:13): [True: 0, False: 0]
  ------------------
  182|      0|            p = multmodp(x2n_table[k & 31], p);
  183|      0|        n >>= 1;
  184|      0|        k++;
  185|      0|    }
  186|      0|    return p;
  187|      0|}
  188|       |
  189|       |#ifdef DYNAMIC_CRC_TABLE
  190|       |/* =========================================================================
  191|       | * Build the tables for byte-wise and braided CRC-32 calculations, and a table
  192|       | * of powers of x for combining CRC-32s.
  193|       | */
  194|       |local z_crc_t FAR crc_table[256];
  195|       |#ifdef W
  196|       |   local z_word_t FAR crc_big_table[256];
  197|       |   local z_crc_t FAR crc_braid_table[W][256];
  198|       |   local z_word_t FAR crc_braid_big_table[W][256];
  199|       |   local void braid(z_crc_t [][256], z_word_t [][256], int, int);
  200|       |#endif
  201|       |#ifdef MAKECRCH
  202|       |   local void write_table(FILE *, const z_crc_t FAR *, int);
  203|       |   local void write_table32hi(FILE *, const z_word_t FAR *, int);
  204|       |   local void write_table64(FILE *, const z_word_t FAR *, int);
  205|       |#endif /* MAKECRCH */
  206|       |
  207|       |/*
  208|       |  Define a once() function depending on the availability of atomics. If this is
  209|       |  compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in
  210|       |  multiple threads, and if atomics are not available, then get_crc_table() must
  211|       |  be called to initialize the tables and must return before any threads are
  212|       |  allowed to compute or combine CRCs.
  213|       | */
  214|       |
  215|       |/* Definition of once functionality. */
  216|       |typedef struct once_s once_t;
  217|       |
  218|       |/* Check for the availability of atomics. */
  219|       |#if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \
  220|       |    !defined(__STDC_NO_ATOMICS__)
  221|       |
  222|       |#include <stdatomic.h>
  223|       |
  224|       |/* Structure for once(), which must be initialized with ONCE_INIT. */
  225|       |struct once_s {
  226|       |    atomic_flag begun;
  227|       |    atomic_int done;
  228|       |};
  229|       |#define ONCE_INIT {ATOMIC_FLAG_INIT, 0}
  230|       |
  231|       |/*
  232|       |  Run the provided init() function exactly once, even if multiple threads
  233|       |  invoke once() at the same time. The state must be a once_t initialized with
  234|       |  ONCE_INIT.
  235|       | */
  236|       |local void once(once_t *state, void (*init)(void)) {
  237|       |    if (!atomic_load(&state->done)) {
  238|       |        if (atomic_flag_test_and_set(&state->begun))
  239|       |            while (!atomic_load(&state->done))
  240|       |                ;
  241|       |        else {
  242|       |            init();
  243|       |            atomic_store(&state->done, 1);
  244|       |        }
  245|       |    }
  246|       |}
  247|       |
  248|       |#else   /* no atomics */
  249|       |
  250|       |/* Structure for once(), which must be initialized with ONCE_INIT. */
  251|       |struct once_s {
  252|       |    volatile int begun;
  253|       |    volatile int done;
  254|       |};
  255|       |#define ONCE_INIT {0, 0}
  256|       |
  257|       |/* Test and set. Alas, not atomic, but tries to minimize the period of
  258|       |   vulnerability. */
  259|       |local int test_and_set(int volatile *flag) {
  260|       |    int was;
  261|       |
  262|       |    was = *flag;
  263|       |    *flag = 1;
  264|       |    return was;
  265|       |}
  266|       |
  267|       |/* Run the provided init() function once. This is not thread-safe. */
  268|       |local void once(once_t *state, void (*init)(void)) {
  269|       |    if (!state->done) {
  270|       |        if (test_and_set(&state->begun))
  271|       |            while (!state->done)
  272|       |                ;
  273|       |        else {
  274|       |            init();
  275|       |            state->done = 1;
  276|       |        }
  277|       |    }
  278|       |}
  279|       |
  280|       |#endif
  281|       |
  282|       |/* State for once(). */
  283|       |local once_t made = ONCE_INIT;
  284|       |
  285|       |/*
  286|       |  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
  287|       |  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
  288|       |
  289|       |  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  290|       |  with the lowest powers in the most significant bit. Then adding polynomials
  291|       |  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  292|       |  one. If we call the above polynomial p, and represent a byte as the
  293|       |  polynomial q, also with the lowest power in the most significant bit (so the
  294|       |  byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,
  295|       |  where a mod b means the remainder after dividing a by b.
  296|       |
  297|       |  This calculation is done using the shift-register method of multiplying and
  298|       |  taking the remainder. The register is initialized to zero, and for each
  299|       |  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  300|       |  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x
  301|       |  (which is shifting right by one and adding x^32 mod p if the bit shifted out
  302|       |  is a one). We start with the highest power (least significant bit) of q and
  303|       |  repeat for all eight bits of q.
  304|       |
  305|       |  The table is simply the CRC of all possible eight bit values. This is all the
  306|       |  information needed to generate CRCs on data a byte at a time for all
  307|       |  combinations of CRC register values and incoming bytes.
  308|       | */
  309|       |
  310|       |local void make_crc_table(void) {
  311|       |    unsigned i, j, n;
  312|       |    z_crc_t p;
  313|       |
  314|       |    /* initialize the CRC of bytes tables */
  315|       |    for (i = 0; i < 256; i++) {
  316|       |        p = i;
  317|       |        for (j = 0; j < 8; j++)
  318|       |            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;
  319|       |        crc_table[i] = p;
  320|       |#ifdef W
  321|       |        crc_big_table[i] = byte_swap(p);
  322|       |#endif
  323|       |    }
  324|       |
  325|       |    /* initialize the x^2^n mod p(x) table */
  326|       |    p = (z_crc_t)1 << 30;         /* x^1 */
  327|       |    x2n_table[0] = p;
  328|       |    for (n = 1; n < 32; n++)
  329|       |        x2n_table[n] = p = multmodp(p, p);
  330|       |
  331|       |#ifdef W
  332|       |    /* initialize the braiding tables -- needs x2n_table[] */
  333|       |    braid(crc_braid_table, crc_braid_big_table, N, W);
  334|       |#endif
  335|       |
  336|       |#ifdef MAKECRCH
  337|       |    {
  338|       |        /*
  339|       |          The crc32.h header file contains tables for both 32-bit and 64-bit
  340|       |          z_word_t's, and so requires a 64-bit type be available. In that case,
  341|       |          z_word_t must be defined to be 64-bits. This code then also generates
  342|       |          and writes out the tables for the case that z_word_t is 32 bits.
  343|       |         */
  344|       |#if !defined(W) || W != 8
  345|       |#  error Need a 64-bit integer type in order to generate crc32.h.
  346|       |#endif
  347|       |        FILE *out;
  348|       |        int k, n;
  349|       |        z_crc_t ltl[8][256];
  350|       |        z_word_t big[8][256];
  351|       |
  352|       |        out = fopen("crc32.h", "w");
  353|       |        if (out == NULL) return;
  354|       |
  355|       |        /* write out little-endian CRC table to crc32.h */
  356|       |        fprintf(out,
  357|       |            "/* crc32.h -- tables for rapid CRC calculation\n"
  358|       |            " * Generated automatically by crc32.c\n */\n"
  359|       |            "\n"
  360|       |            "local const z_crc_t FAR crc_table[] = {\n"
  361|       |            "    ");
  362|       |        write_table(out, crc_table, 256);
  363|       |        fprintf(out,
  364|       |            "};\n");
  365|       |
  366|       |        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */
  367|       |        fprintf(out,
  368|       |            "\n"
  369|       |            "#ifdef W\n"
  370|       |            "\n"
  371|       |            "#if W == 8\n"
  372|       |            "\n"
  373|       |            "local const z_word_t FAR crc_big_table[] = {\n"
  374|       |            "    ");
  375|       |        write_table64(out, crc_big_table, 256);
  376|       |        fprintf(out,
  377|       |            "};\n");
  378|       |
  379|       |        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */
  380|       |        fprintf(out,
  381|       |            "\n"
  382|       |            "#else /* W == 4 */\n"
  383|       |            "\n"
  384|       |            "local const z_word_t FAR crc_big_table[] = {\n"
  385|       |            "    ");
  386|       |        write_table32hi(out, crc_big_table, 256);
  387|       |        fprintf(out,
  388|       |            "};\n"
  389|       |            "\n"
  390|       |            "#endif\n");
  391|       |
  392|       |        /* write out braid tables for each value of N */
  393|       |        for (n = 1; n <= 6; n++) {
  394|       |            fprintf(out,
  395|       |            "\n"
  396|       |            "#if N == %d\n", n);
  397|       |
  398|       |            /* compute braid tables for this N and 64-bit word_t */
  399|       |            braid(ltl, big, n, 8);
  400|       |
  401|       |            /* write out braid tables for 64-bit z_word_t to crc32.h */
  402|       |            fprintf(out,
  403|       |            "\n"
  404|       |            "#if W == 8\n"
  405|       |            "\n"
  406|       |            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
  407|       |            for (k = 0; k < 8; k++) {
  408|       |                fprintf(out, "   {");
  409|       |                write_table(out, ltl[k], 256);
  410|       |                fprintf(out, "}%s", k < 7 ? ",\n" : "");
  411|       |            }
  412|       |            fprintf(out,
  413|       |            "};\n"
  414|       |            "\n"
  415|       |            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
  416|       |            for (k = 0; k < 8; k++) {
  417|       |                fprintf(out, "   {");
  418|       |                write_table64(out, big[k], 256);
  419|       |                fprintf(out, "}%s", k < 7 ? ",\n" : "");
  420|       |            }
  421|       |            fprintf(out,
  422|       |            "};\n");
  423|       |
  424|       |            /* compute braid tables for this N and 32-bit word_t */
  425|       |            braid(ltl, big, n, 4);
  426|       |
  427|       |            /* write out braid tables for 32-bit z_word_t to crc32.h */
  428|       |            fprintf(out,
  429|       |            "\n"
  430|       |            "#else /* W == 4 */\n"
  431|       |            "\n"
  432|       |            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
  433|       |            for (k = 0; k < 4; k++) {
  434|       |                fprintf(out, "   {");
  435|       |                write_table(out, ltl[k], 256);
  436|       |                fprintf(out, "}%s", k < 3 ? ",\n" : "");
  437|       |            }
  438|       |            fprintf(out,
  439|       |            "};\n"
  440|       |            "\n"
  441|       |            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
  442|       |            for (k = 0; k < 4; k++) {
  443|       |                fprintf(out, "   {");
  444|       |                write_table32hi(out, big[k], 256);
  445|       |                fprintf(out, "}%s", k < 3 ? ",\n" : "");
  446|       |            }
  447|       |            fprintf(out,
  448|       |            "};\n"
  449|       |            "\n"
  450|       |            "#endif\n"
  451|       |            "\n"
  452|       |            "#endif\n");
  453|       |        }
  454|       |        fprintf(out,
  455|       |            "\n"
  456|       |            "#endif\n");
  457|       |
  458|       |        /* write out zeros operator table to crc32.h */
  459|       |        fprintf(out,
  460|       |            "\n"
  461|       |            "local const z_crc_t FAR x2n_table[] = {\n"
  462|       |            "    ");
  463|       |        write_table(out, x2n_table, 32);
  464|       |        fprintf(out,
  465|       |            "};\n");
  466|       |        fclose(out);
  467|       |    }
  468|       |#endif /* MAKECRCH */
  469|       |}
  470|       |
  471|       |#ifdef MAKECRCH
  472|       |
  473|       |/*
  474|       |   Write the 32-bit values in table[0..k-1] to out, five per line in
  475|       |   hexadecimal separated by commas.
  476|       | */
  477|       |local void write_table(FILE *out, const z_crc_t FAR *table, int k) {
  478|       |    int n;
  479|       |
  480|       |    for (n = 0; n < k; n++)
  481|       |        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
  482|       |                (unsigned long)(table[n]),
  483|       |                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
  484|       |}
  485|       |
  486|       |/*
  487|       |   Write the high 32-bits of each value in table[0..k-1] to out, five per line
  488|       |   in hexadecimal separated by commas.
  489|       | */
  490|       |local void write_table32hi(FILE *out, const z_word_t FAR *table, int k) {
  491|       |    int n;
  492|       |
  493|       |    for (n = 0; n < k; n++)
  494|       |        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
  495|       |                (unsigned long)(table[n] >> 32),
  496|       |                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
  497|       |}
  498|       |
  499|       |/*
  500|       |  Write the 64-bit values in table[0..k-1] to out, three per line in
  501|       |  hexadecimal separated by commas. This assumes that if there is a 64-bit
  502|       |  type, then there is also a long long integer type, and it is at least 64
  503|       |  bits. If not, then the type cast and format string can be adjusted
  504|       |  accordingly.
  505|       | */
  506|       |local void write_table64(FILE *out, const z_word_t FAR *table, int k) {
  507|       |    int n;
  508|       |
  509|       |    for (n = 0; n < k; n++)
  510|       |        fprintf(out, "%s0x%016llx%s", n == 0 || n % 3 ? "" : "    ",
  511|       |                (unsigned long long)(table[n]),
  512|       |                n == k - 1 ? "" : (n % 3 == 2 ? ",\n" : ", "));
  513|       |}
  514|       |
  515|       |/* Actually do the deed. */
  516|       |int main(void) {
  517|       |    make_crc_table();
  518|       |    return 0;
  519|       |}
  520|       |
  521|       |#endif /* MAKECRCH */
  522|       |
  523|       |#ifdef W
  524|       |/*
  525|       |  Generate the little and big-endian braid tables for the given n and z_word_t
  526|       |  size w. Each array must have room for w blocks of 256 elements.
  527|       | */
  528|       |local void braid(z_crc_t ltl[][256], z_word_t big[][256], int n, int w) {
  529|       |    int k;
  530|       |    z_crc_t i, p, q;
  531|       |    for (k = 0; k < w; k++) {
  532|       |        p = x2nmodp((n * w + 3 - k) << 3, 0);
  533|       |        ltl[k][0] = 0;
  534|       |        big[w - 1 - k][0] = 0;
  535|       |        for (i = 1; i < 256; i++) {
  536|       |            ltl[k][i] = q = multmodp(i << 24, p);
  537|       |            big[w - 1 - k][i] = byte_swap(q);
  538|       |        }
  539|       |    }
  540|       |}
  541|       |#endif
  542|       |
  543|       |#endif /* DYNAMIC_CRC_TABLE */
  544|       |
  545|       |/* =========================================================================
  546|       | * This function can be used by asm versions of crc32(), and to force the
  547|       | * generation of the CRC tables in a threaded application.
  548|       | */
  549|      0|const z_crc_t FAR * ZEXPORT get_crc_table(void) {
  550|       |#ifdef DYNAMIC_CRC_TABLE
  551|       |    once(&made, make_crc_table);
  552|       |#endif /* DYNAMIC_CRC_TABLE */
  553|      0|    return (const z_crc_t FAR *)crc_table;
  554|      0|}
  555|       |
  556|       |/* =========================================================================
  557|       | * Use ARM machine instructions if available. This will compute the CRC about
  558|       | * ten times faster than the braided calculation. This code does not check for
  559|       | * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will
  560|       | * only be defined if the compilation specifies an ARM processor architecture
  561|       | * that has the instructions. For example, compiling with -march=armv8.1-a or
  562|       | * -march=armv8-a+crc, or -march=native if the compile machine has the crc32
  563|       | * instructions.
  564|       | */
  565|       |#ifdef ARMCRC32
  566|       |
  567|       |/*
  568|       |   Constants empirically determined to maximize speed. These values are from
  569|       |   measurements on a Cortex-A57. Your mileage may vary.
  570|       | */
  571|       |#define Z_BATCH 3990                /* number of words in a batch */
  572|       |#define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */
  573|       |#define Z_BATCH_MIN 800             /* fewest words in a final batch */
  574|       |
  575|       |unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,
  576|       |                              z_size_t len) {
  577|       |    z_crc_t val;
  578|       |    z_word_t crc1, crc2;
  579|       |    const z_word_t *word;
  580|       |    z_word_t val0, val1, val2;
  581|       |    z_size_t last, last2, i;
  582|       |    z_size_t num;
  583|       |
  584|       |    /* Return initial CRC, if requested. */
  585|       |    if (buf == Z_NULL) return 0;
  586|       |
  587|       |#ifdef DYNAMIC_CRC_TABLE
  588|       |    once(&made, make_crc_table);
  589|       |#endif /* DYNAMIC_CRC_TABLE */
  590|       |
  591|       |    /* Pre-condition the CRC */
  592|       |    crc = (~crc) & 0xffffffff;
  593|       |
  594|       |    /* Compute the CRC up to a word boundary. */
  595|       |    while (len && ((z_size_t)buf & 7) != 0) {
  596|       |        len--;
  597|       |        val = *buf++;
  598|       |        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
  599|       |    }
  600|       |
  601|       |    /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */
  602|       |    word = (z_word_t const *)buf;
  603|       |    num = len >> 3;
  604|       |    len &= 7;
  605|       |
  606|       |    /* Do three interleaved CRCs to realize the throughput of one crc32x
  607|       |       instruction per cycle. Each CRC is calculated on Z_BATCH words. The
  608|       |       three CRCs are combined into a single CRC after each set of batches. */
  609|       |    while (num >= 3 * Z_BATCH) {
  610|       |        crc1 = 0;
  611|       |        crc2 = 0;
  612|       |        for (i = 0; i < Z_BATCH; i++) {
  613|       |            val0 = word[i];
  614|       |            val1 = word[i + Z_BATCH];
  615|       |            val2 = word[i + 2 * Z_BATCH];
  616|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
  617|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
  618|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
  619|       |        }
  620|       |        word += 3 * Z_BATCH;
  621|       |        num -= 3 * Z_BATCH;
  622|       |        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;
  623|       |        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;
  624|       |    }
  625|       |
  626|       |    /* Do one last smaller batch with the remaining words, if there are enough
  627|       |       to pay for the combination of CRCs. */
  628|       |    last = num / 3;
  629|       |    if (last >= Z_BATCH_MIN) {
  630|       |        last2 = last << 1;
  631|       |        crc1 = 0;
  632|       |        crc2 = 0;
  633|       |        for (i = 0; i < last; i++) {
  634|       |            val0 = word[i];
  635|       |            val1 = word[i + last];
  636|       |            val2 = word[i + last2];
  637|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
  638|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
  639|       |            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
  640|       |        }
  641|       |        word += 3 * last;
  642|       |        num -= 3 * last;
  643|       |        val = x2nmodp(last, 6);
  644|       |        crc = multmodp(val, crc) ^ crc1;
  645|       |        crc = multmodp(val, crc) ^ crc2;
  646|       |    }
  647|       |
  648|       |    /* Compute the CRC on any remaining words. */
  649|       |    for (i = 0; i < num; i++) {
  650|       |        val0 = word[i];
  651|       |        __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
  652|       |    }
  653|       |    word += num;
  654|       |
  655|       |    /* Complete the CRC on any remaining bytes. */
  656|       |    buf = (const unsigned char FAR *)word;
  657|       |    while (len) {
  658|       |        len--;
  659|       |        val = *buf++;
  660|       |        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
  661|       |    }
  662|       |
  663|       |    /* Return the CRC, post-conditioned. */
  664|       |    return crc ^ 0xffffffff;
  665|       |}
  666|       |
  667|       |#else
  668|       |
  669|       |#ifdef W
  670|       |
  671|       |/*
  672|       |  Return the CRC of the W bytes in the word_t data, taking the
  673|       |  least-significant byte of the word as the first byte of data, without any pre
  674|       |  or post conditioning. This is used to combine the CRCs of each braid.
  675|       | */
  676|      0|local z_crc_t crc_word(z_word_t data) {
  677|      0|    int k;
  678|      0|    for (k = 0; k < W; k++)
  ------------------
  |  Branch (678:17): [True: 0, False: 0]
  ------------------
  679|      0|        data = (data >> 8) ^ crc_table[data & 0xff];
  680|      0|    return (z_crc_t)data;
  681|      0|}
  682|       |
  683|      0|local z_word_t crc_word_big(z_word_t data) {
  684|      0|    int k;
  685|      0|    for (k = 0; k < W; k++)
  ------------------
  |  Branch (685:17): [True: 0, False: 0]
  ------------------
  686|      0|        data = (data << 8) ^
  687|      0|            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];
  688|      0|    return data;
  689|      0|}
  690|       |
  691|       |#endif
  692|       |
  693|       |/* ========================================================================= */
  694|       |unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,
  695|  3.31M|                              z_size_t len) {
  696|       |    /* Return initial CRC, if requested. */
  697|  3.31M|    if (buf == Z_NULL) return 0;
  ------------------
  |  Branch (697:9): [True: 3.31M, False: 0]
  ------------------
  698|       |
  699|       |#ifdef DYNAMIC_CRC_TABLE
  700|       |    once(&made, make_crc_table);
  701|       |#endif /* DYNAMIC_CRC_TABLE */
  702|       |
  703|       |    /* Pre-condition the CRC */
  704|      0|    crc = (~crc) & 0xffffffff;
  705|       |
  706|      0|#ifdef W
  707|       |
  708|       |    /* If provided enough bytes, do a braided CRC calculation. */
  709|      0|    if (len >= N * W + W - 1) {
  ------------------
  |  Branch (709:9): [True: 0, False: 0]
  ------------------
  710|      0|        z_size_t blks;
  711|      0|        z_word_t const *words;
  712|      0|        unsigned endian;
  713|      0|        int k;
  714|       |
  715|       |        /* Compute the CRC up to a z_word_t boundary. */
  716|      0|        while (len && ((z_size_t)buf & (W - 1)) != 0) {
  ------------------
  |  Branch (716:16): [True: 0, False: 0]
  |  Branch (716:23): [True: 0, False: 0]
  ------------------
  717|      0|            len--;
  718|      0|            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  719|      0|        }
  720|       |
  721|       |        /* Compute the CRC on as many N z_word_t blocks as are available. */
  722|      0|        blks = len / (N * W);
  723|      0|        len -= blks * N * W;
  724|      0|        words = (z_word_t const *)buf;
  725|       |
  726|       |        /* Do endian check at execution time instead of compile time, since ARM
  727|       |           processors can change the endianness at execution time. If the
  728|       |           compiler knows what the endianness will be, it can optimize out the
  729|       |           check and the unused branch. */
  730|      0|        endian = 1;
  731|      0|        if (*(unsigned char *)&endian) {
  ------------------
  |  Branch (731:13): [True: 0, False: 0]
  ------------------
  732|       |            /* Little endian. */
  733|       |
  734|      0|            z_crc_t crc0;
  735|      0|            z_word_t word0;
  736|      0|#if N > 1
  737|      0|            z_crc_t crc1;
  738|      0|            z_word_t word1;
  739|      0|#if N > 2
  740|      0|            z_crc_t crc2;
  741|      0|            z_word_t word2;
  742|      0|#if N > 3
  743|      0|            z_crc_t crc3;
  744|      0|            z_word_t word3;
  745|      0|#if N > 4
  746|      0|            z_crc_t crc4;
  747|      0|            z_word_t word4;
  748|       |#if N > 5
  749|       |            z_crc_t crc5;
  750|       |            z_word_t word5;
  751|       |#endif
  752|      0|#endif
  753|      0|#endif
  754|      0|#endif
  755|      0|#endif
  756|       |
  757|       |            /* Initialize the CRC for each braid. */
  758|      0|            crc0 = crc;
  759|      0|#if N > 1
  760|      0|            crc1 = 0;
  761|      0|#if N > 2
  762|      0|            crc2 = 0;
  763|      0|#if N > 3
  764|      0|            crc3 = 0;
  765|      0|#if N > 4
  766|      0|            crc4 = 0;
  767|       |#if N > 5
  768|       |            crc5 = 0;
  769|       |#endif
  770|      0|#endif
  771|      0|#endif
  772|      0|#endif
  773|      0|#endif
  774|       |
  775|       |            /*
  776|       |              Process the first blks-1 blocks, computing the CRCs on each braid
  777|       |              independently.
  778|       |             */
  779|      0|            while (--blks) {
  ------------------
  |  Branch (779:20): [True: 0, False: 0]
  ------------------
  780|       |                /* Load the word for each braid into registers. */
  781|      0|                word0 = crc0 ^ words[0];
  782|      0|#if N > 1
  783|      0|                word1 = crc1 ^ words[1];
  784|      0|#if N > 2
  785|      0|                word2 = crc2 ^ words[2];
  786|      0|#if N > 3
  787|      0|                word3 = crc3 ^ words[3];
  788|      0|#if N > 4
  789|      0|                word4 = crc4 ^ words[4];
  790|       |#if N > 5
  791|       |                word5 = crc5 ^ words[5];
  792|       |#endif
  793|      0|#endif
  794|      0|#endif
  795|      0|#endif
  796|      0|#endif
  797|      0|                words += N;
  798|       |
  799|       |                /* Compute and update the CRC for each word. The loop should
  800|       |                   get unrolled. */
  801|      0|                crc0 = crc_braid_table[0][word0 & 0xff];
  802|      0|#if N > 1
  803|      0|                crc1 = crc_braid_table[0][word1 & 0xff];
  804|      0|#if N > 2
  805|      0|                crc2 = crc_braid_table[0][word2 & 0xff];
  806|      0|#if N > 3
  807|      0|                crc3 = crc_braid_table[0][word3 & 0xff];
  808|      0|#if N > 4
  809|      0|                crc4 = crc_braid_table[0][word4 & 0xff];
  810|       |#if N > 5
  811|       |                crc5 = crc_braid_table[0][word5 & 0xff];
  812|       |#endif
  813|      0|#endif
  814|      0|#endif
  815|      0|#endif
  816|      0|#endif
  817|      0|                for (k = 1; k < W; k++) {
  ------------------
  |  Branch (817:29): [True: 0, False: 0]
  ------------------
  818|      0|                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
  819|      0|#if N > 1
  820|      0|                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
  821|      0|#if N > 2
  822|      0|                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
  823|      0|#if N > 3
  824|      0|                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
  825|      0|#if N > 4
  826|      0|                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
  827|       |#if N > 5
  828|       |                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
  829|       |#endif
  830|      0|#endif
  831|      0|#endif
  832|      0|#endif
  833|      0|#endif
  834|      0|                }
  835|      0|            }
  836|       |
  837|       |            /*
  838|       |              Process the last block, combining the CRCs of the N braids at the
  839|       |              same time.
  840|       |             */
  841|      0|            crc = crc_word(crc0 ^ words[0]);
  842|      0|#if N > 1
  843|      0|            crc = crc_word(crc1 ^ words[1] ^ crc);
  844|      0|#if N > 2
  845|      0|            crc = crc_word(crc2 ^ words[2] ^ crc);
  846|      0|#if N > 3
  847|      0|            crc = crc_word(crc3 ^ words[3] ^ crc);
  848|      0|#if N > 4
  849|      0|            crc = crc_word(crc4 ^ words[4] ^ crc);
  850|       |#if N > 5
  851|       |            crc = crc_word(crc5 ^ words[5] ^ crc);
  852|       |#endif
  853|      0|#endif
  854|      0|#endif
  855|      0|#endif
  856|      0|#endif
  857|      0|            words += N;
  858|      0|        }
  859|      0|        else {
  860|       |            /* Big endian. */
  861|       |
  862|      0|            z_word_t crc0, word0, comb;
  863|      0|#if N > 1
  864|      0|            z_word_t crc1, word1;
  865|      0|#if N > 2
  866|      0|            z_word_t crc2, word2;
  867|      0|#if N > 3
  868|      0|            z_word_t crc3, word3;
  869|      0|#if N > 4
  870|      0|            z_word_t crc4, word4;
  871|       |#if N > 5
  872|       |            z_word_t crc5, word5;
  873|       |#endif
  874|      0|#endif
  875|      0|#endif
  876|      0|#endif
  877|      0|#endif
  878|       |
  879|       |            /* Initialize the CRC for each braid. */
  880|      0|            crc0 = byte_swap(crc);
  881|      0|#if N > 1
  882|      0|            crc1 = 0;
  883|      0|#if N > 2
  884|      0|            crc2 = 0;
  885|      0|#if N > 3
  886|      0|            crc3 = 0;
  887|      0|#if N > 4
  888|      0|            crc4 = 0;
  889|       |#if N > 5
  890|       |            crc5 = 0;
  891|       |#endif
  892|      0|#endif
  893|      0|#endif
  894|      0|#endif
  895|      0|#endif
  896|       |
  897|       |            /*
  898|       |              Process the first blks-1 blocks, computing the CRCs on each braid
  899|       |              independently.
  900|       |             */
  901|      0|            while (--blks) {
  ------------------
  |  Branch (901:20): [True: 0, False: 0]
  ------------------
  902|       |                /* Load the word for each braid into registers. */
  903|      0|                word0 = crc0 ^ words[0];
  904|      0|#if N > 1
  905|      0|                word1 = crc1 ^ words[1];
  906|      0|#if N > 2
  907|      0|                word2 = crc2 ^ words[2];
  908|      0|#if N > 3
  909|      0|                word3 = crc3 ^ words[3];
  910|      0|#if N > 4
  911|      0|                word4 = crc4 ^ words[4];
  912|       |#if N > 5
  913|       |                word5 = crc5 ^ words[5];
  914|       |#endif
  915|      0|#endif
  916|      0|#endif
  917|      0|#endif
  918|      0|#endif
  919|      0|                words += N;
  920|       |
  921|       |                /* Compute and update the CRC for each word. The loop should
  922|       |                   get unrolled. */
  923|      0|                crc0 = crc_braid_big_table[0][word0 & 0xff];
  924|      0|#if N > 1
  925|      0|                crc1 = crc_braid_big_table[0][word1 & 0xff];
  926|      0|#if N > 2
  927|      0|                crc2 = crc_braid_big_table[0][word2 & 0xff];
  928|      0|#if N > 3
  929|      0|                crc3 = crc_braid_big_table[0][word3 & 0xff];
  930|      0|#if N > 4
  931|      0|                crc4 = crc_braid_big_table[0][word4 & 0xff];
  932|       |#if N > 5
  933|       |                crc5 = crc_braid_big_table[0][word5 & 0xff];
  934|       |#endif
  935|      0|#endif
  936|      0|#endif
  937|      0|#endif
  938|      0|#endif
  939|      0|                for (k = 1; k < W; k++) {
  ------------------
  |  Branch (939:29): [True: 0, False: 0]
  ------------------
  940|      0|                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
  941|      0|#if N > 1
  942|      0|                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
  943|      0|#if N > 2
  944|      0|                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
  945|      0|#if N > 3
  946|      0|                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
  947|      0|#if N > 4
  948|      0|                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
  949|       |#if N > 5
  950|       |                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
  951|       |#endif
  952|      0|#endif
  953|      0|#endif
  954|      0|#endif
  955|      0|#endif
  956|      0|                }
  957|      0|            }
  958|       |
  959|       |            /*
  960|       |              Process the last block, combining the CRCs of the N braids at the
  961|       |              same time.
  962|       |             */
  963|      0|            comb = crc_word_big(crc0 ^ words[0]);
  964|      0|#if N > 1
  965|      0|            comb = crc_word_big(crc1 ^ words[1] ^ comb);
  966|      0|#if N > 2
  967|      0|            comb = crc_word_big(crc2 ^ words[2] ^ comb);
  968|      0|#if N > 3
  969|      0|            comb = crc_word_big(crc3 ^ words[3] ^ comb);
  970|      0|#if N > 4
  971|      0|            comb = crc_word_big(crc4 ^ words[4] ^ comb);
  972|       |#if N > 5
  973|       |            comb = crc_word_big(crc5 ^ words[5] ^ comb);
  974|       |#endif
  975|      0|#endif
  976|      0|#endif
  977|      0|#endif
  978|      0|#endif
  979|      0|            words += N;
  980|      0|            crc = byte_swap(comb);
  981|      0|        }
  982|       |
  983|       |        /*
  984|       |          Update the pointer to the remaining bytes to process.
  985|       |         */
  986|      0|        buf = (unsigned char const *)words;
  987|      0|    }
  988|       |
  989|      0|#endif /* W */
  990|       |
  991|       |    /* Complete the computation of the CRC on any remaining bytes. */
  992|      0|    while (len >= 8) {
  ------------------
  |  Branch (992:12): [True: 0, False: 0]
  ------------------
  993|      0|        len -= 8;
  994|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  995|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  996|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  997|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  998|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  999|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1000|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1001|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1002|      0|    }
 1003|      0|    while (len) {
  ------------------
  |  Branch (1003:12): [True: 0, False: 0]
  ------------------
 1004|      0|        len--;
 1005|      0|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1006|      0|    }
 1007|       |
 1008|       |    /* Return the CRC, post-conditioned. */
 1009|      0|    return crc ^ 0xffffffff;
 1010|  3.31M|}
 1011|       |
 1012|       |#endif
 1013|       |
 1014|       |/* ========================================================================= */
 1015|       |unsigned long ZEXPORT crc32(unsigned long crc, const unsigned char FAR *buf,
 1016|  3.31M|                            uInt len) {
 1017|  3.31M|    return crc32_z(crc, buf, len);
 1018|  3.31M|}
 1019|       |
 1020|       |/* ========================================================================= */
 1021|      0|uLong ZEXPORT crc32_combine64(uLong crc1, uLong crc2, z_off64_t len2) {
 1022|       |#ifdef DYNAMIC_CRC_TABLE
 1023|       |    once(&made, make_crc_table);
 1024|       |#endif /* DYNAMIC_CRC_TABLE */
 1025|      0|    return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);
 1026|      0|}
 1027|       |
 1028|       |/* ========================================================================= */
 1029|      0|uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2) {
 1030|      0|    return crc32_combine64(crc1, crc2, (z_off64_t)len2);
 1031|      0|}
 1032|       |
 1033|       |/* ========================================================================= */
 1034|      0|uLong ZEXPORT crc32_combine_gen64(z_off64_t len2) {
 1035|       |#ifdef DYNAMIC_CRC_TABLE
 1036|       |    once(&made, make_crc_table);
 1037|       |#endif /* DYNAMIC_CRC_TABLE */
 1038|      0|    return x2nmodp(len2, 3);
 1039|      0|}
 1040|       |
 1041|       |/* ========================================================================= */
 1042|      0|uLong ZEXPORT crc32_combine_gen(z_off_t len2) {
 1043|      0|    return crc32_combine_gen64((z_off64_t)len2);
 1044|      0|}
 1045|       |
 1046|       |/* ========================================================================= */
 1047|      0|uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op) {
 1048|      0|    return multmodp(op, crc1) ^ (crc2 & 0xffffffff);
 1049|      0|}

/home/minseo/alfha/targets/zlib/target/deflate.c:
    1|       |/* deflate.c -- compress data using the deflation algorithm
    2|       | * Copyright (C) 1995-2025 Jean-loup Gailly and Mark Adler
    3|       | * For conditions of distribution and use, see copyright notice in zlib.h
    4|       | */
    5|       |
    6|       |/*
    7|       | *  ALGORITHM
    8|       | *
    9|       | *      The "deflation" process depends on being able to identify portions
   10|       | *      of the input text which are identical to earlier input (within a
   11|       | *      sliding window trailing behind the input currently being processed).
   12|       | *
   13|       | *      The most straightforward technique turns out to be the fastest for
   14|       | *      most input files: try all possible matches and select the longest.
   15|       | *      The key feature of this algorithm is that insertions into the string
   16|       | *      dictionary are very simple and thus fast, and deletions are avoided
   17|       | *      completely. Insertions are performed at each input character, whereas
   18|       | *      string matches are performed only when the previous match ends. So it
   19|       | *      is preferable to spend more time in matches to allow very fast string
   20|       | *      insertions and avoid deletions. The matching algorithm for small
   21|       | *      strings is inspired from that of Rabin & Karp. A brute force approach
   22|       | *      is used to find longer strings when a small match has been found.
   23|       | *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
   24|       | *      (by Leonid Broukhis).
   25|       | *         A previous version of this file used a more sophisticated algorithm
   26|       | *      (by Fiala and Greene) which is guaranteed to run in linear amortized
   27|       | *      time, but has a larger average cost, uses more memory and is patented.
   28|       | *      However the F&G algorithm may be faster for some highly redundant
   29|       | *      files if the parameter max_chain_length (described below) is too large.
   30|       | *
   31|       | *  ACKNOWLEDGEMENTS
   32|       | *
   33|       | *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
   34|       | *      I found it in 'freeze' written by Leonid Broukhis.
   35|       | *      Thanks to many people for bug reports and testing.
   36|       | *
   37|       | *  REFERENCES
   38|       | *
   39|       | *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
   40|       | *      Available at https://datatracker.ietf.org/doc/html/rfc1951
   41|       | *
   42|       | *      A description of the Rabin and Karp algorithm is given in the book
   43|       | *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
   44|       | *
   45|       | *      Fiala,E.R., and Greene,D.H.
   46|       | *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
   47|       | *
   48|       | */
   49|       |
   50|       |/* @(#) $Id$ */
   51|       |
   52|       |#include "deflate.h"
   53|       |
   54|       |const char deflate_copyright[] =
   55|       |   " deflate 1.3.1.2 Copyright 1995-2025 Jean-loup Gailly and Mark Adler ";
   56|       |/*
   57|       |  If you use the zlib library in a product, an acknowledgment is welcome
   58|       |  in the documentation of your product. If for some reason you cannot
   59|       |  include such an acknowledgment, I would appreciate that you keep this
   60|       |  copyright string in the executable of your product.
   61|       | */
   62|       |
   63|       |typedef enum {
   64|       |    need_more,      /* block not completed, need more input or more output */
   65|       |    block_done,     /* block flush performed */
   66|       |    finish_started, /* finish started, need only more output at next deflate */
   67|       |    finish_done     /* finish done, accept no more input or output */
   68|       |} block_state;
   69|       |
   70|       |typedef block_state (*compress_func)(deflate_state *s, int flush);
   71|       |/* Compression function. Returns the block state after the call. */
   72|       |
   73|       |local block_state deflate_stored(deflate_state *s, int flush);
   74|       |local block_state deflate_fast(deflate_state *s, int flush);
   75|       |#ifndef FASTEST
   76|       |local block_state deflate_slow(deflate_state *s, int flush);
   77|       |#endif
   78|       |local block_state deflate_rle(deflate_state *s, int flush);
   79|       |local block_state deflate_huff(deflate_state *s, int flush);
   80|       |
   81|       |/* ===========================================================================
   82|       | * Local data
   83|       | */
   84|       |
   85|  1.57G|#define NIL 0
   86|       |/* Tail of hash chains */
   87|       |
   88|       |#ifndef TOO_FAR
   89|  19.3M|#  define TOO_FAR 4096
   90|       |#endif
   91|       |/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
   92|       |
   93|       |/* Values for max_lazy_match, good_match and max_chain_length, depending on
   94|       | * the desired pack level (0..9). The values given below have been tuned to
   95|       | * exclude worst case performance for pathological files. Better values may be
   96|       | * found for specific files.
   97|       | */
   98|       |typedef struct config_s {
   99|       |   ush good_length; /* reduce lazy search above this match length */
  100|       |   ush max_lazy;    /* do not perform lazy search above this match length */
  101|       |   ush nice_length; /* quit search above this match length */
  102|       |   ush max_chain;
  103|       |   compress_func func;
  104|       |} config;
  105|       |
  106|       |#ifdef FASTEST
  107|       |local const config configuration_table[2] = {
  108|       |/*      good lazy nice chain */
  109|       |/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
  110|       |/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
  111|       |#else
  112|       |local const config configuration_table[10] = {
  113|       |/*      good lazy nice chain */
  114|       |/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
  115|       |/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
  116|       |/* 2 */ {4,    5, 16,    8, deflate_fast},
  117|       |/* 3 */ {4,    6, 32,   32, deflate_fast},
  118|       |
  119|       |/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
  120|       |/* 5 */ {8,   16, 32,   32, deflate_slow},
  121|       |/* 6 */ {8,   16, 128, 128, deflate_slow},
  122|       |/* 7 */ {8,   32, 128, 256, deflate_slow},
  123|       |/* 8 */ {32, 128, 258, 1024, deflate_slow},
  124|       |/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
  125|       |#endif
  126|       |
  127|       |/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
  128|       | * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
  129|       | * meaning.
  130|       | */
  131|       |
  132|       |/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
  133|  59.3M|#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
                                            ^8.62M    ^0  ^8.62M
  134|       |
  135|       |/* ===========================================================================
  136|       | * Update a hash value with the given input byte
  137|       | * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
  138|       | *    characters, so that a running hash key can be computed from the previous
  139|       | *    key instead of complete recalculation each time.
  140|       | */
  141|  2.79G|#define UPDATE_HASH(s,h,c) (h = (((h) << s->hash_shift) ^ (c)) & s->hash_mask)
  142|       |
  143|       |
  144|       |/* ===========================================================================
  145|       | * Insert string str in the dictionary and set match_head to the previous head
  146|       | * of the hash chain (the most recent string with same hash key). Return
  147|       | * the previous length of the hash chain.
  148|       | * If this file is compiled with -DFASTEST, the compression level is forced
  149|       | * to 1, and no hash chains are maintained.
  150|       | * IN  assertion: all calls to INSERT_STRING are made with consecutive input
  151|       | *    characters and the first MIN_MATCH bytes of str are valid (except for
  152|       | *    the last MIN_MATCH-1 bytes of the input file).
  153|       | */
  154|       |#ifdef FASTEST
  155|       |#define INSERT_STRING(s, str, match_head) \
  156|       |   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
  157|       |    match_head = s->head[s->ins_h], \
  158|       |    s->head[s->ins_h] = (Pos)(str))
  159|       |#else
  160|       |#define INSERT_STRING(s, str, match_head) \
  161|  2.74G|   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
  162|  2.74G|    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
  163|  2.74G|    s->head[s->ins_h] = (Pos)(str))
  164|       |#endif
  165|       |
  166|       |/* ===========================================================================
  167|       | * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
  168|       | * prev[] will be initialized on the fly.
  169|       | */
  170|       |#define CLEAR_HASH(s) \
  171|  70.9M|    do { \
  172|  70.9M|        s->head[s->hash_size - 1] = NIL; \
  173|  70.9M|        zmemzero((Bytef *)s->head, \
  174|  70.9M|                 (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \
  175|  70.9M|    } while (0)
  176|       |
  177|       |/* ===========================================================================
  178|       | * Slide the hash table when sliding the window down (could be avoided with 32
  179|       | * bit values at the expense of memory usage). We slide even when level == 0 to
  180|       | * keep the hash table consistent if we switch back to level > 0 later.
  181|       | */
  182|       |#if defined(__has_feature)
  183|       |#  if __has_feature(memory_sanitizer)
  184|       |     __attribute__((no_sanitize("memory")))
  185|       |#  endif
  186|       |#endif
  187|      0|local void slide_hash(deflate_state *s) {
  188|      0|    unsigned n, m;
  189|      0|    Posf *p;
  190|      0|    uInt wsize = s->w_size;
  191|       |
  192|      0|    n = s->hash_size;
  193|      0|    p = &s->head[n];
  194|      0|    do {
  195|      0|        m = *--p;
  196|      0|        *p = (Pos)(m >= wsize ? m - wsize : NIL);
  ------------------
  |  Branch (196:20): [True: 0, False: 0]
  ------------------
  197|      0|    } while (--n);
  ------------------
  |  Branch (197:14): [True: 0, False: 0]
  ------------------
  198|      0|    n = wsize;
  199|      0|#ifndef FASTEST
  200|      0|    p = &s->prev[n];
  201|      0|    do {
  202|      0|        m = *--p;
  203|      0|        *p = (Pos)(m >= wsize ? m - wsize : NIL);
  ------------------
  |  Branch (203:20): [True: 0, False: 0]
  ------------------
  204|       |        /* If n is not on any hash chain, prev[n] is garbage but
  205|       |         * its value will never be used.
  206|       |         */
  207|      0|    } while (--n);
  ------------------
  |  Branch (207:14): [True: 0, False: 0]
  ------------------
  208|      0|#endif
  209|      0|}
  210|       |
  211|       |/* ===========================================================================
  212|       | * Read a new buffer from the current input stream, update the adler32
  213|       | * and total number of bytes read.  All deflate() input goes through
  214|       | * this function so some applications may wish to modify it to avoid
  215|       | * allocating a large strm->next_in buffer and copying from it.
  216|       | * (See also flush_pending()).
  217|       | */
  218|  46.3M|local unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {
  219|  46.3M|    unsigned len = strm->avail_in;
  220|       |
  221|  46.3M|    if (len > size) len = size;
                                  ^0
  ------------------
  |  Branch (221:9): [True: 0, False: 46.3M]
  ------------------
  222|  46.3M|    if (len == 0) return 0;
                                ^0
  ------------------
  |  Branch (222:9): [True: 0, False: 46.3M]
  ------------------
  223|       |
  224|  46.3M|    strm->avail_in  -= len;
  225|       |
  226|  46.3M|    zmemcpy(buf, strm->next_in, len);
  227|  46.3M|    if (strm->state->wrap == 1) {
  ------------------
  |  Branch (227:9): [True: 46.3M, False: 0]
  ------------------
  228|  46.3M|        strm->adler = adler32(strm->adler, buf, len);
  229|  46.3M|    }
  230|      0|#ifdef GZIP
  231|      0|    else if (strm->state->wrap == 2) {
  ------------------
  |  Branch (231:14): [True: 0, False: 0]
  ------------------
  232|      0|        strm->adler = crc32(strm->adler, buf, len);
  233|      0|    }
  234|  46.3M|#endif
  235|  46.3M|    strm->next_in  += len;
  236|  46.3M|    strm->total_in += len;
  237|       |
  238|  46.3M|    return len;
  239|  46.3M|}
  240|       |
  241|       |/* ===========================================================================
  242|       | * Fill the window when the lookahead becomes insufficient.
  243|       | * Updates strstart and lookahead.
  244|       | *
  245|       | * IN assertion: lookahead < MIN_LOOKAHEAD
  246|       | * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
  247|       | *    At least one byte has been read, or avail_in == 0; reads are
  248|       | *    performed for at least two bytes (required for the zip translate_eol
  249|       | *    option -- not supported here).
  250|       | */
  251|   477M|local void fill_window(deflate_state *s) {
  252|   477M|    unsigned n;
  253|   477M|    unsigned more;    /* Amount of free space at the end of the window. */
  254|   477M|    uInt wsize = s->w_size;
  255|       |
  256|   477M|    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
  257|       |
  258|   477M|    do {
  259|   477M|        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
  260|       |
  261|       |        /* Deal with !@#$% 64K limit: */
  262|   477M|        if (sizeof(int) <= 2) {
  ------------------
  |  Branch (262:13): [Folded - Ignored]
  ------------------
  263|      0|            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
  ------------------
  |  Branch (263:17): [True: 0, False: 0]
  |  Branch (263:30): [True: 0, False: 0]
  |  Branch (263:50): [True: 0, False: 0]
  ------------------
  264|      0|                more = wsize;
  265|       |
  266|      0|            } else if (more == (unsigned)(-1)) {
  ------------------
  |  Branch (266:24): [True: 0, False: 0]
  ------------------
  267|       |                /* Very unlikely, but possible on 16 bit machine if
  268|       |                 * strstart == 0 && lookahead == 1 (input done a byte at time)
  269|       |                 */
  270|      0|                more--;
  271|      0|            }
  272|      0|        }
  273|       |
  274|       |        /* If the window is almost full and there is insufficient lookahead,
  275|       |         * move the upper half to the lower one to make room in the upper half.
  276|       |         */
  277|   477M|        if (s->strstart >= wsize + MAX_DIST(s)) {
  ------------------
  |  Branch (277:13): [True: 0, False: 477M]
  ------------------
  278|       |
  279|      0|            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);
  280|      0|            s->match_start -= wsize;
  281|      0|            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
  282|      0|            s->block_start -= (long) wsize;
  283|      0|            if (s->insert > s->strstart)
  ------------------
  |  Branch (283:17): [True: 0, False: 0]
  ------------------
  284|      0|                s->insert = s->strstart;
  285|      0|            slide_hash(s);
  286|      0|            more += wsize;
  287|      0|        }
  288|   477M|        if (s->strm->avail_in == 0) break;
                                                  ^431M
  ------------------
  |  Branch (288:13): [True: 431M, False: 46.3M]
  ------------------
  289|       |
  290|       |        /* If there was no sliding:
  291|       |         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
  292|       |         *    more == window_size - lookahead - strstart
  293|       |         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
  294|       |         * => more >= window_size - 2*WSIZE + 2
  295|       |         * In the BIG_MEM or MMAP case (not yet supported),
  296|       |         *   window_size == input_size + MIN_LOOKAHEAD  &&
  297|       |         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
  298|       |         * Otherwise, window_size == 2*WSIZE so more >= 2.
  299|       |         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
  300|       |         */
  301|  46.3M|        Assert(more >= 2, "more < 2");
  302|       |
  303|  46.3M|        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
  304|  46.3M|        s->lookahead += n;
  305|       |
  306|       |        /* Initialize the hash value now that we have some input: */
  307|  46.3M|        if (s->lookahead + s->insert >= MIN_MATCH) {
  ------------------
  |  Branch (307:13): [True: 40.1M, False: 6.20M]
  ------------------
  308|  40.1M|            uInt str = s->strstart - s->insert;
  309|  40.1M|            s->ins_h = s->window[str];
  310|  40.1M|            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
  311|       |#if MIN_MATCH != 3
  312|       |            Call UPDATE_HASH() MIN_MATCH-3 more times
  313|       |#endif
  314|  55.1M|            while (s->insert) {
  ------------------
  |  Branch (314:20): [True: 16.4M, False: 38.7M]
  ------------------
  315|  16.4M|                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
  316|  16.4M|#ifndef FASTEST
  317|  16.4M|                s->prev[str & s->w_mask] = s->head[s->ins_h];
  318|  16.4M|#endif
  319|  16.4M|                s->head[s->ins_h] = (Pos)str;
  320|  16.4M|                str++;
  321|  16.4M|                s->insert--;
  322|  16.4M|                if (s->lookahead + s->insert < MIN_MATCH)
  ------------------
  |  Branch (322:21): [True: 1.45M, False: 15.0M]
  ------------------
  323|  1.45M|                    break;
  324|  16.4M|            }
  325|  40.1M|        }
  326|       |        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
  327|       |         * but this is not important since only literal bytes will be emitted.
  328|       |         */
  329|       |
  330|  46.3M|    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
                                                           ^44.3M
  ------------------
  |  Branch (330:14): [True: 44.3M, False: 1.96M]
  |  Branch (330:46): [True: 0, False: 44.3M]
  ------------------
  331|       |
  332|       |    /* If the WIN_INIT bytes after the end of the current data have never been
  333|       |     * written, then zero those bytes in order to avoid memory check reports of
  334|       |     * the use of uninitialized (or uninitialised as Julian writes) bytes by
  335|       |     * the longest match routines.  Update the high water mark for the next
  336|       |     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
  337|       |     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
  338|       |     */
  339|   477M|    if (s->high_water < s->window_size) {
  ------------------
  |  Branch (339:9): [True: 477M, False: 0]
  ------------------
  340|   477M|        ulg curr = s->strstart + (ulg)(s->lookahead);
  341|   477M|        ulg init;
  342|       |
  343|   477M|        if (s->high_water < curr) {
  ------------------
  |  Branch (343:13): [True: 16.8M, False: 460M]
  ------------------
  344|       |            /* Previous high water mark below current data -- zero WIN_INIT
  345|       |             * bytes or up to end of window, whichever is less.
  346|       |             */
  347|  16.8M|            init = s->window_size - curr;
  348|  16.8M|            if (init > WIN_INIT)
  ------------------
  |  Branch (348:17): [True: 16.8M, False: 0]
  ------------------
  349|  16.8M|                init = WIN_INIT;
  350|  16.8M|            zmemzero(s->window + curr, (unsigned)init);
  351|  16.8M|            s->high_water = curr + init;
  352|  16.8M|        }
  353|   460M|        else if (s->high_water < (ulg)curr + WIN_INIT) {
  ------------------
  |  Branch (353:18): [True: 25.1M, False: 435M]
  ------------------
  354|       |            /* High water mark at or above current data, but below current data
  355|       |             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  356|       |             * to end of window, whichever is less.
  357|       |             */
  358|  25.1M|            init = (ulg)curr + WIN_INIT - s->high_water;
  359|  25.1M|            if (init > s->window_size - s->high_water)
  ------------------
  |  Branch (359:17): [True: 0, False: 25.1M]
  ------------------
  360|      0|                init = s->window_size - s->high_water;
  361|  25.1M|            zmemzero(s->window + s->high_water, (unsigned)init);
  362|  25.1M|            s->high_water += init;
  363|  25.1M|        }
  364|   477M|    }
  365|       |
  366|   477M|    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  367|   477M|           "not enough room for search");
  368|   477M|}
  369|       |
  370|       |/* ========================================================================= */
  371|       |int ZEXPORT deflateInit_(z_streamp strm, int level, const char *version,
  372|  60.1M|                         int stream_size) {
  373|  60.1M|    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
  374|  60.1M|                         Z_DEFAULT_STRATEGY, version, stream_size);
  375|       |    /* To do: ignore strm->next_in if we use it as window */
  376|  60.1M|}
  377|       |
  378|       |/* ========================================================================= */
  379|       |int ZEXPORT deflateInit2_(z_streamp strm, int level, int method,
  380|       |                          int windowBits, int memLevel, int strategy,
  381|  96.1M|                          const char *version, int stream_size) {
  382|  96.1M|    deflate_state *s;
  383|  96.1M|    int wrap = 1;
  384|  96.1M|    static const char my_version[] = ZLIB_VERSION;
  385|       |
  386|  96.1M|    if (version == Z_NULL || version[0] != my_version[0] ||
  ------------------
  |  Branch (386:9): [True: 0, False: 96.1M]
  |  Branch (386:30): [True: 0, False: 96.1M]
  ------------------
  387|  96.1M|        stream_size != sizeof(z_stream)) {
  ------------------
  |  Branch (387:9): [True: 0, False: 96.1M]
  ------------------
  388|      0|        return Z_VERSION_ERROR;
  389|      0|    }
  390|  96.1M|    if (strm == Z_NULL) return Z_STREAM_ERROR;
                                      ^2.14M ^2.14M
  ------------------
  |  Branch (390:9): [True: 2.14M, False: 94.0M]
  ------------------
  391|       |
  392|  94.0M|    strm->msg = Z_NULL;
  393|  94.0M|    if (strm->zalloc == (alloc_func)0) {
  ------------------
  |  Branch (393:9): [True: 94.0M, False: 0]
  ------------------
  394|       |#ifdef Z_SOLO
  395|       |        return Z_STREAM_ERROR;
  396|       |#else
  397|  94.0M|        strm->zalloc = zcalloc;
  398|  94.0M|        strm->opaque = (voidpf)0;
  399|  94.0M|#endif
  400|  94.0M|    }
  401|  94.0M|    if (strm->zfree == (free_func)0)
  ------------------
  |  Branch (401:9): [True: 94.0M, False: 0]
  ------------------
  402|       |#ifdef Z_SOLO
  403|       |        return Z_STREAM_ERROR;
  404|       |#else
  405|  94.0M|        strm->zfree = zcfree;
  406|  94.0M|#endif
  407|       |
  408|       |#ifdef FASTEST
  409|       |    if (level != 0) level = 1;
  410|       |#else
  411|  94.0M|    if (level == Z_DEFAULT_COMPRESSION) level = 6;
                                                      ^44.1M
  ------------------
  |  Branch (411:9): [True: 44.1M, False: 49.8M]
  ------------------
  412|  94.0M|#endif
  413|       |
  414|  94.0M|    if (windowBits < 0) { /* suppress zlib wrapper */
  ------------------
  |  Branch (414:9): [True: 5.91M, False: 88.1M]
  ------------------
  415|  5.91M|        wrap = 0;
  416|  5.91M|        if (windowBits < -15)
  ------------------
  |  Branch (416:13): [True: 1.08M, False: 4.82M]
  ------------------
  417|  1.08M|            return Z_STREAM_ERROR;
  418|  4.82M|        windowBits = -windowBits;
  419|  4.82M|    }
  420|  88.1M|#ifdef GZIP
  421|  88.1M|    else if (windowBits > 15) {
  ------------------
  |  Branch (421:14): [True: 5.48M, False: 82.6M]
  ------------------
  422|  5.48M|        wrap = 2;       /* write gzip wrapper instead */
  423|  5.48M|        windowBits -= 16;
  424|  5.48M|    }
  425|  92.9M|#endif
  426|  92.9M|    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
                                      ^91.9M     ^91.9M           ^90.4M    ^90.4M
  ------------------
  |  Branch (426:9): [True: 1.00M, False: 91.9M]
  |  Branch (426:25): [True: 1.44M, False: 90.4M]
  |  Branch (426:53): [True: 2.30M, False: 88.1M]
  ------------------
  427|  92.9M|        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
                      ^88.1M            ^86.3M             ^85.2M       ^78.0M
  ------------------
  |  Branch (427:9): [True: 1.84M, False: 86.3M]
  |  Branch (427:27): [True: 1.10M, False: 85.2M]
  |  Branch (427:46): [True: 7.19M, False: 78.0M]
  |  Branch (427:59): [True: 9.20M, False: 68.8M]
  ------------------
  428|  92.9M|        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
                      ^68.8M          ^68.4M     ^68.4M     ^67.3M^67.3M             ^1.10M
  ------------------
  |  Branch (428:9): [True: 368k, False: 68.4M]
  |  Branch (428:25): [True: 1.10M, False: 67.3M]
  |  Branch (428:48): [True: 1.10M, False: 66.2M]
  |  Branch (428:67): [True: 736k, False: 368k]
  ------------------
  429|  26.3M|        return Z_STREAM_ERROR;
  430|  26.3M|    }
  431|  66.6M|    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
                                       ^368k
  ------------------
  |  Branch (431:9): [True: 368k, False: 66.2M]
  ------------------
  432|  66.6M|    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
  433|  66.6M|    if (s == Z_NULL) return Z_MEM_ERROR;
                                   ^0     ^0
  ------------------
  |  Branch (433:9): [True: 0, False: 66.6M]
  ------------------
  434|  66.6M|    strm->state = (struct internal_state FAR *)s;
  435|  66.6M|    s->strm = strm;
  436|  66.6M|    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
  437|       |
  438|  66.6M|    s->wrap = wrap;
  439|  66.6M|    s->gzhead = Z_NULL;
  440|  66.6M|    s->w_bits = (uInt)windowBits;
  441|  66.6M|    s->w_size = 1 << s->w_bits;
  442|  66.6M|    s->w_mask = s->w_size - 1;
  443|       |
  444|  66.6M|    s->hash_bits = (uInt)memLevel + 7;
  445|  66.6M|    s->hash_size = 1 << s->hash_bits;
  446|  66.6M|    s->hash_mask = s->hash_size - 1;
  447|  66.6M|    s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
  448|       |
  449|  66.6M|    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
  450|  66.6M|    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
  451|  66.6M|    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
  452|       |
  453|  66.6M|    s->high_water = 0;      /* nothing written to s->window yet */
  454|       |
  455|  66.6M|    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
  456|       |
  457|       |    /* We overlay pending_buf and sym_buf. This works since the average size
  458|       |     * for length/distance pairs over any compressed block is assured to be 31
  459|       |     * bits or less.
  460|       |     *
  461|       |     * Analysis: The longest fixed codes are a length code of 8 bits plus 5
  462|       |     * extra bits, for lengths 131 to 257. The longest fixed distance codes are
  463|       |     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
  464|       |     * possible fixed-codes length/distance pair is then 31 bits total.
  465|       |     *
  466|       |     * sym_buf starts one-fourth of the way into pending_buf. So there are
  467|       |     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
  468|       |     * in sym_buf is three bytes -- two for the distance and one for the
  469|       |     * literal/length. As each symbol is consumed, the pointer to the next
  470|       |     * sym_buf value to read moves forward three bytes. From that symbol, up to
  471|       |     * 31 bits are written to pending_buf. The closest the written pending_buf
  472|       |     * bits gets to the next sym_buf symbol to read is just before the last
  473|       |     * code is written. At that time, 31*(n - 2) bits have been written, just
  474|       |     * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
  475|       |     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
  476|       |     * symbols are written.) The closest the writing gets to what is unread is
  477|       |     * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
  478|       |     * can range from 128 to 32768.
  479|       |     *
  480|       |     * Therefore, at a minimum, there are 142 bits of space between what is
  481|       |     * written and what is read in the overlain buffers, so the symbols cannot
  482|       |     * be overwritten by the compressed data. That space is actually 139 bits,
  483|       |     * due to the three-bit fixed-code block header.
  484|       |     *
  485|       |     * That covers the case where either Z_FIXED is specified, forcing fixed
  486|       |     * codes, or when the use of fixed codes is chosen, because that choice
  487|       |     * results in a smaller compressed block than dynamic codes. That latter
  488|       |     * condition then assures that the above analysis also covers all dynamic
  489|       |     * blocks. A dynamic-code block will only be chosen to be emitted if it has
  490|       |     * fewer bits than a fixed-code block would for the same set of symbols.
  491|       |     * Therefore its average symbol length is assured to be less than 31. So
  492|       |     * the compressed data for a dynamic block also cannot overwrite the
  493|       |     * symbols from which it is being constructed.
  494|       |     */
  495|       |
  496|  66.6M|    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);
  497|  66.6M|    s->pending_buf_size = (ulg)s->lit_bufsize * 4;
  498|       |
  499|  66.6M|    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
  ------------------
  |  Branch (499:9): [True: 0, False: 66.6M]
  |  Branch (499:32): [True: 0, False: 66.6M]
  |  Branch (499:53): [True: 0, False: 66.6M]
  ------------------
  500|  66.6M|        s->pending_buf == Z_NULL) {
  ------------------
  |  Branch (500:9): [True: 0, False: 66.6M]
  ------------------
  501|      0|        s->status = FINISH_STATE;
  502|      0|        strm->msg = ERR_MSG(Z_MEM_ERROR);
  503|      0|        deflateEnd (strm);
  504|      0|        return Z_MEM_ERROR;
  505|      0|    }
  506|       |#ifdef LIT_MEM
  507|       |    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));
  508|       |    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);
  509|       |    s->sym_end = s->lit_bufsize - 1;
  510|       |#else
  511|  66.6M|    s->sym_buf = s->pending_buf + s->lit_bufsize;
  512|  66.6M|    s->sym_end = (s->lit_bufsize - 1) * 3;
  513|  66.6M|#endif
  514|       |    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
  515|       |     * on 16 bit machines and because stored blocks are restricted to
  516|       |     * 64K-1 bytes.
  517|       |     */
  518|       |
  519|  66.6M|    s->level = level;
  520|  66.6M|    s->strategy = strategy;
  521|  66.6M|    s->method = (Byte)method;
  522|       |
  523|  66.6M|    return deflateReset(strm);
  524|  66.6M|}
  525|       |
  526|       |/* =========================================================================
  527|       | * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
  528|       | */
  529|   200M|local int deflateStateCheck(z_streamp strm) {
  530|   200M|    deflate_state *s;
  531|   200M|    if (strm == Z_NULL ||
  ------------------
  |  Branch (531:9): [True: 4.31M, False: 196M]
  ------------------
  532|   200M|        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
                      ^196M                            ^196M
  ------------------
  |  Branch (532:9): [True: 0, False: 196M]
  |  Branch (532:42): [True: 0, False: 196M]
  ------------------
  533|  4.31M|        return 1;
  534|   196M|    s = strm->state;
  535|   196M|    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
  ------------------
  |  Branch (535:9): [True: 0, False: 196M]
  |  Branch (535:24): [True: 0, False: 196M]
  |  Branch (535:44): [True: 53.9M, False: 142M]
  ------------------
  536|   196M|#ifdef GZIP
  537|   196M|                                           s->status != GZIP_STATE &&
                                                         ^53.9M       ^53.9M
  ------------------
  |  Branch (537:44): [True: 50.6M, False: 3.31M]
  ------------------
  538|   196M|#endif
  539|   196M|                                           s->status != EXTRA_STATE &&
                                                         ^50.6M       ^50.6M
  ------------------
  |  Branch (539:44): [True: 50.6M, False: 0]
  ------------------
  540|   196M|                                           s->status != NAME_STATE &&
                                                         ^50.6M       ^50.6M
  ------------------
  |  Branch (540:44): [True: 50.6M, False: 0]
  ------------------
  541|   196M|                                           s->status != COMMENT_STATE &&
                                                         ^50.6M       ^50.6M
  ------------------
  |  Branch (541:44): [True: 50.6M, False: 0]
  ------------------
  542|   196M|                                           s->status != HCRC_STATE &&
                                                         ^50.6M       ^50.6M
  ------------------
  |  Branch (542:44): [True: 50.6M, False: 0]
  ------------------
  543|   196M|                                           s->status != BUSY_STATE &&
                                                         ^50.6M       ^50.6M
  ------------------
  |  Branch (543:44): [True: 15.2M, False: 35.4M]
  ------------------
  544|   196M|                                           s->status != FINISH_STATE))
                                                         ^15.2M       ^15.2M
  ------------------
  |  Branch (544:44): [True: 0, False: 15.2M]
  ------------------
  545|      0|        return 1;
  546|   196M|    return 0;
  547|   196M|}
  548|       |
  549|       |/* ========================================================================= */
  550|       |int ZEXPORT deflateSetDictionary(z_streamp strm, const Bytef *dictionary,
  551|      0|                                 uInt  dictLength) {
  552|      0|    deflate_state *s;
  553|      0|    uInt str, n;
  554|      0|    int wrap;
  555|      0|    unsigned avail;
  556|      0|    z_const unsigned char *next;
  557|       |
  558|      0|    if (deflateStateCheck(strm) || dictionary == Z_NULL)
  ------------------
  |  Branch (558:9): [True: 0, False: 0]
  |  Branch (558:36): [True: 0, False: 0]
  ------------------
  559|      0|        return Z_STREAM_ERROR;
  560|      0|    s = strm->state;
  561|      0|    wrap = s->wrap;
  562|      0|    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
  ------------------
  |  Branch (562:9): [True: 0, False: 0]
  |  Branch (562:23): [True: 0, False: 0]
  |  Branch (562:36): [True: 0, False: 0]
  |  Branch (562:64): [True: 0, False: 0]
  ------------------
  563|      0|        return Z_STREAM_ERROR;
  564|       |
  565|       |    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  566|      0|    if (wrap == 1)
  ------------------
  |  Branch (566:9): [True: 0, False: 0]
  ------------------
  567|      0|        strm->adler = adler32(strm->adler, dictionary, dictLength);
  568|      0|    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
  569|       |
  570|       |    /* if dictionary would fill window, just replace the history */
  571|      0|    if (dictLength >= s->w_size) {
  ------------------
  |  Branch (571:9): [True: 0, False: 0]
  ------------------
  572|      0|        if (wrap == 0) {            /* already empty otherwise */
  ------------------
  |  Branch (572:13): [True: 0, False: 0]
  ------------------
  573|      0|            CLEAR_HASH(s);
  574|      0|            s->strstart = 0;
  575|      0|            s->block_start = 0L;
  576|      0|            s->insert = 0;
  577|      0|        }
  578|      0|        dictionary += dictLength - s->w_size;  /* use the tail */
  579|      0|        dictLength = s->w_size;
  580|      0|    }
  581|       |
  582|       |    /* insert dictionary into window and hash */
  583|      0|    avail = strm->avail_in;
  584|      0|    next = strm->next_in;
  585|      0|    strm->avail_in = dictLength;
  586|      0|    strm->next_in = (z_const Bytef *)dictionary;
  587|      0|    fill_window(s);
  588|      0|    while (s->lookahead >= MIN_MATCH) {
  ------------------
  |  Branch (588:12): [True: 0, False: 0]
  ------------------
  589|      0|        str = s->strstart;
  590|      0|        n = s->lookahead - (MIN_MATCH-1);
  591|      0|        do {
  592|      0|            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
  593|      0|#ifndef FASTEST
  594|      0|            s->prev[str & s->w_mask] = s->head[s->ins_h];
  595|      0|#endif
  596|      0|            s->head[s->ins_h] = (Pos)str;
  597|      0|            str++;
  598|      0|        } while (--n);
  ------------------
  |  Branch (598:18): [True: 0, False: 0]
  ------------------
  599|      0|        s->strstart = str;
  600|      0|        s->lookahead = MIN_MATCH-1;
  601|      0|        fill_window(s);
  602|      0|    }
  603|      0|    s->strstart += s->lookahead;
  604|      0|    s->block_start = (long)s->strstart;
  605|      0|    s->insert = s->lookahead;
  606|      0|    s->lookahead = 0;
  607|      0|    s->match_length = s->prev_length = MIN_MATCH-1;
  608|      0|    s->match_available = 0;
  609|      0|    strm->next_in = next;
  610|      0|    strm->avail_in = avail;
  611|      0|    s->wrap = wrap;
  612|      0|    return Z_OK;
  613|      0|}
  614|       |
  615|       |/* ========================================================================= */
  616|       |int ZEXPORT deflateGetDictionary(z_streamp strm, Bytef *dictionary,
  617|      0|                                 uInt *dictLength) {
  618|      0|    deflate_state *s;
  619|      0|    uInt len;
  620|       |
  621|      0|    if (deflateStateCheck(strm))
  ------------------
  |  Branch (621:9): [True: 0, False: 0]
  ------------------
  622|      0|        return Z_STREAM_ERROR;
  623|      0|    s = strm->state;
  624|      0|    len = s->strstart + s->lookahead;
  625|      0|    if (len > s->w_size)
  ------------------
  |  Branch (625:9): [True: 0, False: 0]
  ------------------
  626|      0|        len = s->w_size;
  627|      0|    if (dictionary != Z_NULL && len)
  ------------------
  |  Branch (627:9): [True: 0, False: 0]
  |  Branch (627:33): [True: 0, False: 0]
  ------------------
  628|      0|        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
  629|      0|    if (dictLength != Z_NULL)
  ------------------
  |  Branch (629:9): [True: 0, False: 0]
  ------------------
  630|      0|        *dictLength = len;
  631|      0|    return Z_OK;
  632|      0|}
  633|       |
  634|       |/* ========================================================================= */
  635|  66.6M|int ZEXPORT deflateResetKeep(z_streamp strm) {
  636|  66.6M|    deflate_state *s;
  637|       |
  638|  66.6M|    if (deflateStateCheck(strm)) {
  ------------------
  |  Branch (638:9): [True: 0, False: 66.6M]
  ------------------
  639|      0|        return Z_STREAM_ERROR;
  640|      0|    }
  641|       |
  642|  66.6M|    strm->total_in = strm->total_out = 0;
  643|  66.6M|    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
  644|  66.6M|    strm->data_type = Z_UNKNOWN;
  645|       |
  646|  66.6M|    s = (deflate_state *)strm->state;
  647|  66.6M|    s->pending = 0;
  648|  66.6M|    s->pending_out = s->pending_buf;
  649|       |
  650|  66.6M|    if (s->wrap < 0) {
  ------------------
  |  Branch (650:9): [True: 0, False: 66.6M]
  ------------------
  651|      0|        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
  652|      0|    }
  653|  66.6M|    s->status =
  654|  66.6M|#ifdef GZIP
  655|  66.6M|        s->wrap == 2 ? GZIP_STATE :
                                     ^3.31M
  ------------------
  |  Branch (655:9): [True: 3.31M, False: 63.3M]
  ------------------
  656|  66.6M|#endif
  657|  66.6M|        INIT_STATE;
                      ^63.3M
  658|  66.6M|    strm->adler =
  659|  66.6M|#ifdef GZIP
  660|  66.6M|        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
                                     ^3.31M    ^3.31M
  ------------------
  |  Branch (660:9): [True: 3.31M, False: 63.3M]
  ------------------
  661|  66.6M|#endif
  662|  66.6M|        adler32(0L, Z_NULL, 0);
                      ^63.3M      ^63.3M
  663|  66.6M|    s->last_flush = -2;
  664|       |
  665|  66.6M|    _tr_init(s);
  666|       |
  667|  66.6M|    return Z_OK;
  668|  66.6M|}
  669|       |
  670|       |/* ===========================================================================
  671|       | * Initialize the "longest match" routines for a new zlib stream
  672|       | */
  673|  66.6M|local void lm_init(deflate_state *s) {
  674|  66.6M|    s->window_size = (ulg)2L*s->w_size;
  675|       |
  676|  66.6M|    CLEAR_HASH(s);
  677|       |
  678|       |    /* Set the default configuration parameters:
  679|       |     */
  680|  66.6M|    s->max_lazy_match   = configuration_table[s->level].max_lazy;
  681|  66.6M|    s->good_match       = configuration_table[s->level].good_length;
  682|  66.6M|    s->nice_match       = configuration_table[s->level].nice_length;
  683|  66.6M|    s->max_chain_length = configuration_table[s->level].max_chain;
  684|       |
  685|  66.6M|    s->strstart = 0;
  686|  66.6M|    s->block_start = 0L;
  687|  66.6M|    s->lookahead = 0;
  688|  66.6M|    s->insert = 0;
  689|  66.6M|    s->match_length = s->prev_length = MIN_MATCH-1;
  690|  66.6M|    s->match_available = 0;
  691|  66.6M|    s->ins_h = 0;
  692|  66.6M|}
  693|       |
  694|       |/* ========================================================================= */
  695|  66.6M|int ZEXPORT deflateReset(z_streamp strm) {
  696|  66.6M|    int ret;
  697|       |
  698|  66.6M|    ret = deflateResetKeep(strm);
  699|  66.6M|    if (ret == Z_OK)
  ------------------
  |  Branch (699:9): [True: 66.6M, False: 0]
  ------------------
  700|  66.6M|        lm_init(strm->state);
  701|  66.6M|    return ret;
  702|  66.6M|}
  703|       |
  704|       |/* ========================================================================= */
  705|      0|int ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {
  706|      0|    if (deflateStateCheck(strm) || strm->state->wrap != 2)
  ------------------
  |  Branch (706:9): [True: 0, False: 0]
  |  Branch (706:36): [True: 0, False: 0]
  ------------------
  707|      0|        return Z_STREAM_ERROR;
  708|      0|    strm->state->gzhead = head;
  709|      0|    return Z_OK;
  710|      0|}
  711|       |
  712|       |/* ========================================================================= */
  713|      0|int ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {
  714|      0|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  ------------------
  |  Branch (714:9): [True: 0, False: 0]
  ------------------
  715|      0|    if (pending != Z_NULL)
  ------------------
  |  Branch (715:9): [True: 0, False: 0]
  ------------------
  716|      0|        *pending = strm->state->pending;
  717|      0|    if (bits != Z_NULL)
  ------------------
  |  Branch (717:9): [True: 0, False: 0]
  ------------------
  718|      0|        *bits = strm->state->bi_valid;
  719|      0|    return Z_OK;
  720|      0|}
  721|       |
  722|       |/* ========================================================================= */
  723|      0|int ZEXPORT deflateUsed(z_streamp strm, int *bits) {
  724|      0|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  ------------------
  |  Branch (724:9): [True: 0, False: 0]
  ------------------
  725|      0|    if (bits != Z_NULL)
  ------------------
  |  Branch (725:9): [True: 0, False: 0]
  ------------------
  726|      0|        *bits = strm->state->bi_used;
  727|      0|    return Z_OK;
  728|      0|}
  729|       |
  730|       |/* ========================================================================= */
  731|      0|int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {
  732|      0|    deflate_state *s;
  733|      0|    int put;
  734|       |
  735|      0|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  ------------------
  |  Branch (735:9): [True: 0, False: 0]
  ------------------
  736|      0|    s = strm->state;
  737|       |#ifdef LIT_MEM
  738|       |    if (bits < 0 || bits > 16 ||
  739|       |        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))
  740|       |        return Z_BUF_ERROR;
  741|       |#else
  742|      0|    if (bits < 0 || bits > 16 ||
  ------------------
  |  Branch (742:9): [True: 0, False: 0]
  |  Branch (742:21): [True: 0, False: 0]
  ------------------
  743|      0|        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
  ------------------
  |  Branch (743:9): [True: 0, False: 0]
  ------------------
  744|      0|        return Z_BUF_ERROR;
  745|      0|#endif
  746|      0|    do {
  747|      0|        put = Buf_size - s->bi_valid;
  748|      0|        if (put > bits)
  ------------------
  |  Branch (748:13): [True: 0, False: 0]
  ------------------
  749|      0|            put = bits;
  750|      0|        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
  751|      0|        s->bi_valid += put;
  752|      0|        _tr_flush_bits(s);
  753|      0|        value >>= put;
  754|      0|        bits -= put;
  755|      0|    } while (bits);
  ------------------
  |  Branch (755:14): [True: 0, False: 0]
  ------------------
  756|      0|    return Z_OK;
  757|      0|}
  758|       |
  759|       |/* ========================================================================= */
  760|      0|int ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {
  761|      0|    deflate_state *s;
  762|      0|    compress_func func;
  763|       |
  764|      0|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  ------------------
  |  Branch (764:9): [True: 0, False: 0]
  ------------------
  765|      0|    s = strm->state;
  766|       |
  767|       |#ifdef FASTEST
  768|       |    if (level != 0) level = 1;
  769|       |#else
  770|      0|    if (level == Z_DEFAULT_COMPRESSION) level = 6;
  ------------------
  |  Branch (770:9): [True: 0, False: 0]
  ------------------
  771|      0|#endif
  772|      0|    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
  ------------------
  |  Branch (772:9): [True: 0, False: 0]
  |  Branch (772:22): [True: 0, False: 0]
  |  Branch (772:35): [True: 0, False: 0]
  |  Branch (772:51): [True: 0, False: 0]
  ------------------
  773|      0|        return Z_STREAM_ERROR;
  774|      0|    }
  775|      0|    func = configuration_table[s->level].func;
  776|       |
  777|      0|    if ((strategy != s->strategy || func != configuration_table[level].func) &&
  ------------------
  |  Branch (777:10): [True: 0, False: 0]
  |  Branch (777:37): [True: 0, False: 0]
  ------------------
  778|      0|        s->last_flush != -2) {
  ------------------
  |  Branch (778:9): [True: 0, False: 0]
  ------------------
  779|       |        /* Flush the last buffer: */
  780|      0|        int err = deflate(strm, Z_BLOCK);
  781|      0|        if (err == Z_STREAM_ERROR)
  ------------------
  |  Branch (781:13): [True: 0, False: 0]
  ------------------
  782|      0|            return err;
  783|      0|        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
  ------------------
  |  Branch (783:13): [True: 0, False: 0]
  |  Branch (783:31): [True: 0, False: 0]
  ------------------
  784|      0|            return Z_BUF_ERROR;
  785|      0|    }
  786|      0|    if (s->level != level) {
  ------------------
  |  Branch (786:9): [True: 0, False: 0]
  ------------------
  787|      0|        if (s->level == 0 && s->matches != 0) {
  ------------------
  |  Branch (787:13): [True: 0, False: 0]
  |  Branch (787:30): [True: 0, False: 0]
  ------------------
  788|      0|            if (s->matches == 1)
  ------------------
  |  Branch (788:17): [True: 0, False: 0]
  ------------------
  789|      0|                slide_hash(s);
  790|      0|            else
  791|      0|                CLEAR_HASH(s);
  792|      0|            s->matches = 0;
  793|      0|        }
  794|      0|        s->level = level;
  795|      0|        s->max_lazy_match   = configuration_table[level].max_lazy;
  796|      0|        s->good_match       = configuration_table[level].good_length;
  797|      0|        s->nice_match       = configuration_table[level].nice_length;
  798|      0|        s->max_chain_length = configuration_table[level].max_chain;
  799|      0|    }
  800|      0|    s->strategy = strategy;
  801|      0|    return Z_OK;
  802|      0|}
  803|       |
  804|       |/* ========================================================================= */
  805|       |int ZEXPORT deflateTune(z_streamp strm, int good_length, int max_lazy,
  806|      0|                        int nice_length, int max_chain) {
  807|      0|    deflate_state *s;
  808|       |
  809|      0|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  ------------------
  |  Branch (809:9): [True: 0, False: 0]
  ------------------
  810|      0|    s = strm->state;
  811|      0|    s->good_match = (uInt)good_length;
  812|      0|    s->max_lazy_match = (uInt)max_lazy;
  813|      0|    s->nice_match = nice_length;
  814|      0|    s->max_chain_length = (uInt)max_chain;
  815|      0|    return Z_OK;
  816|      0|}
  817|       |
  818|       |/* =========================================================================
  819|       | * For the default windowBits of 15 and memLevel of 8, this function returns a
  820|       | * close to exact, as well as small, upper bound on the compressed size. This
  821|       | * is an expansion of ~0.03%, plus a small constant.
  822|       | *
  823|       | * For any setting other than those defaults for windowBits and memLevel, one
  824|       | * of two worst case bounds is returned. This is at most an expansion of ~4% or
  825|       | * ~13%, plus a small constant.
  826|       | *
  827|       | * Both the 0.03% and 4% derive from the overhead of stored blocks. The first
  828|       | * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second
  829|       | * is for stored blocks of 127 bytes (the worst case memLevel == 1). The
  830|       | * expansion results from five bytes of header for each stored block.
  831|       | *
  832|       | * The larger expansion of 13% results from a window size less than or equal to
  833|       | * the symbols buffer size (windowBits <= memLevel + 7). In that case some of
  834|       | * the data being compressed may have slid out of the sliding window, impeding
  835|       | * a stored block from being emitted. Then the only choice is a fixed or
  836|       | * dynamic block, where a fixed block limits the maximum expansion to 9 bits
  837|       | * per 8-bit byte, plus 10 bits for every block. The smallest block size for
  838|       | * which this can occur is 255 (memLevel == 2).
  839|       | *
  840|       | * Shifts are used to approximate divisions, for speed.
  841|       | */
  842|      0|uLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {
  843|      0|    deflate_state *s;
  844|      0|    uLong fixedlen, storelen, wraplen;
  845|       |
  846|       |    /* upper bound for fixed blocks with 9-bit literals and length 255
  847|       |       (memLevel == 2, which is the lowest that may not use stored blocks) --
  848|       |       ~13% overhead plus a small constant */
  849|      0|    fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +
  850|      0|               (sourceLen >> 9) + 4;
  851|       |
  852|       |    /* upper bound for stored blocks with length 127 (memLevel == 1) --
  853|       |       ~4% overhead plus a small constant */
  854|      0|    storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +
  855|      0|               (sourceLen >> 11) + 7;
  856|       |
  857|       |    /* if can't get parameters, return larger bound plus a wrapper */
  858|      0|    if (deflateStateCheck(strm))
  ------------------
  |  Branch (858:9): [True: 0, False: 0]
  ------------------
  859|      0|        return (fixedlen > storelen ? fixedlen : storelen) + 18;
  ------------------
  |  Branch (859:17): [True: 0, False: 0]
  ------------------
  860|       |
  861|       |    /* compute wrapper length */
  862|      0|    s = strm->state;
  863|      0|    switch (s->wrap < 0 ? -s->wrap : s->wrap) {
  ------------------
  |  Branch (863:13): [True: 0, False: 0]
  ------------------
  864|      0|    case 0:                                 /* raw deflate */
  ------------------
  |  Branch (864:5): [True: 0, False: 0]
  ------------------
  865|      0|        wraplen = 0;
  866|      0|        break;
  867|      0|    case 1:                                 /* zlib wrapper */
  ------------------
  |  Branch (867:5): [True: 0, False: 0]
  ------------------
  868|      0|        wraplen = 6 + (s->strstart ? 4 : 0);
  ------------------
  |  Branch (868:24): [True: 0, False: 0]
  ------------------
  869|      0|        break;
  870|      0|#ifdef GZIP
  871|      0|    case 2:                                 /* gzip wrapper */
  ------------------
  |  Branch (871:5): [True: 0, False: 0]
  ------------------
  872|      0|        wraplen = 18;
  873|      0|        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
  ------------------
  |  Branch (873:13): [True: 0, False: 0]
  ------------------
  874|      0|            Bytef *str;
  875|      0|            if (s->gzhead->extra != Z_NULL)
  ------------------
  |  Branch (875:17): [True: 0, False: 0]
  ------------------
  876|      0|                wraplen += 2 + s->gzhead->extra_len;
  877|      0|            str = s->gzhead->name;
  878|      0|            if (str != Z_NULL)
  ------------------
  |  Branch (878:17): [True: 0, False: 0]
  ------------------
  879|      0|                do {
  880|      0|                    wraplen++;
  881|      0|                } while (*str++);
  ------------------
  |  Branch (881:26): [True: 0, False: 0]
  ------------------
  882|      0|            str = s->gzhead->comment;
  883|      0|            if (str != Z_NULL)
  ------------------
  |  Branch (883:17): [True: 0, False: 0]
  ------------------
  884|      0|                do {
  885|      0|                    wraplen++;
  886|      0|                } while (*str++);
  ------------------
  |  Branch (886:26): [True: 0, False: 0]
  ------------------
  887|      0|            if (s->gzhead->hcrc)
  ------------------
  |  Branch (887:17): [True: 0, False: 0]
  ------------------
  888|      0|                wraplen += 2;
  889|      0|        }
  890|      0|        break;
  891|      0|#endif
  892|      0|    default:                                /* for compiler happiness */
  ------------------
  |  Branch (892:5): [True: 0, False: 0]
  ------------------
  893|      0|        wraplen = 18;
  894|      0|    }
  895|       |
  896|       |    /* if not default parameters, return one of the conservative bounds */
  897|      0|    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
  ------------------
  |  Branch (897:9): [True: 0, False: 0]
  |  Branch (897:28): [True: 0, False: 0]
  ------------------
  898|      0|        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +
  ------------------
  |  Branch (898:17): [True: 0, False: 0]
  |  Branch (898:46): [True: 0, False: 0]
  ------------------
  899|      0|               wraplen;
  900|       |
  901|       |    /* default settings: return tight bound for that case -- ~0.03% overhead
  902|       |       plus a small constant */
  903|      0|    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
  904|      0|           (sourceLen >> 25) + 13 - 6 + wraplen;
  905|      0|}
  906|       |
  907|       |/* =========================================================================
  908|       | * Put a short in the pending buffer. The 16-bit value is put in MSB order.
  909|       | * IN assertion: the stream state is correct and there is enough room in
  910|       | * pending_buf.
  911|       | */
  912|  46.4M|local void putShortMSB(deflate_state *s, uInt b) {
  913|  46.4M|    put_byte(s, (Byte)(b >> 8));
  914|  46.4M|    put_byte(s, (Byte)(b & 0xff));
  915|  46.4M|}
  916|       |
  917|       |/* =========================================================================
  918|       | * Flush as much pending output as possible. All deflate() output, except for
  919|       | * some deflate_stored() output, goes through this function so some
  920|       | * applications may wish to modify it to avoid allocating a large
  921|       | * strm->next_out buffer and copying into it. (See also read_buf()).
  922|       | */
  923|  72.5M|local void flush_pending(z_streamp strm) {
  924|  72.5M|    unsigned len;
  925|  72.5M|    deflate_state *s = strm->state;
  926|       |
  927|  72.5M|    _tr_flush_bits(s);
  928|  72.5M|    len = s->pending;
  929|  72.5M|    if (len > strm->avail_out) len = strm->avail_out;
                                             ^0
  ------------------
  |  Branch (929:9): [True: 0, False: 72.5M]
  ------------------
  930|  72.5M|    if (len == 0) return;
                                ^5.36k
  ------------------
  |  Branch (930:9): [True: 5.36k, False: 72.5M]
  ------------------
  931|       |
  932|  72.5M|    zmemcpy(strm->next_out, s->pending_out, len);
  933|  72.5M|    strm->next_out  += len;
  934|  72.5M|    s->pending_out  += len;
  935|  72.5M|    strm->total_out += len;
  936|  72.5M|    strm->avail_out -= len;
  937|  72.5M|    s->pending      -= len;
  938|  72.5M|    if (s->pending == 0) {
  ------------------
  |  Branch (938:9): [True: 72.5M, False: 0]
  ------------------
  939|  72.5M|        s->pending_out = s->pending_buf;
  940|  72.5M|    }
  941|  72.5M|}
  942|       |
  943|       |/* ===========================================================================
  944|       | * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
  945|       | */
  946|       |#define HCRC_UPDATE(beg) \
  947|      0|    do { \
  948|      0|        if (s->gzhead->hcrc && s->pending > (beg)) \
  949|      0|            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
  950|      0|                                s->pending - (beg)); \
  951|      0|    } while (0)
  952|       |
  953|       |/* ========================================================================= */
  954|  67.2M|int ZEXPORT deflate(z_streamp strm, int flush) {
  955|  67.2M|    int old_flush; /* value of flush param for previous deflate call */
  956|  67.2M|    deflate_state *s;
  957|       |
  958|  67.2M|    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
                                                 ^62.9M  ^62.9M     ^59.3M
  ------------------
  |  Branch (958:9): [True: 4.31M, False: 62.9M]
  |  Branch (958:36): [True: 3.60M, False: 59.3M]
  |  Branch (958:55): [True: 0, False: 59.3M]
  ------------------
  959|  7.91M|        return Z_STREAM_ERROR;
  960|  7.91M|    }
  961|  59.3M|    s = strm->state;
  962|       |
  963|  59.3M|    if (strm->next_out == Z_NULL ||
  ------------------
  |  Branch (963:9): [True: 4.31M, False: 54.9M]
  ------------------
  964|  59.3M|        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
                      ^54.9M^54.9M                 ^50.6M           ^50.6M
  ------------------
  |  Branch (964:10): [True: 50.6M, False: 4.31M]
  |  Branch (964:33): [True: 0, False: 50.6M]
  ------------------
  965|  59.3M|        (s->status == FINISH_STATE && flush != Z_FINISH)) {
                      ^54.9M^54.9M       ^54.9M          ^0       ^0
  ------------------
  |  Branch (965:10): [True: 0, False: 54.9M]
  |  Branch (965:39): [True: 0, False: 0]
  ------------------
  966|  4.31M|        ERR_RETURN(strm, Z_STREAM_ERROR);
  967|  4.31M|    }
  968|  54.9M|    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
                                            ^4.31M
  ------------------
  |  Branch (968:9): [True: 4.31M, False: 50.6M]
  ------------------
  969|       |
  970|  50.6M|    old_flush = s->last_flush;
  971|  50.6M|    s->last_flush = flush;
  972|       |
  973|       |    /* Flush as much pending output as possible */
  974|  50.6M|    if (s->pending != 0) {
  ------------------
  |  Branch (974:9): [True: 0, False: 50.6M]
  ------------------
  975|      0|        flush_pending(strm);
  976|      0|        if (strm->avail_out == 0) {
  ------------------
  |  Branch (976:13): [True: 0, False: 0]
  ------------------
  977|       |            /* Since avail_out is 0, deflate will be called again with
  978|       |             * more output space, but possibly with both pending and
  979|       |             * avail_in equal to zero. There won't be anything to do,
  980|       |             * but this is not an error situation so make sure we
  981|       |             * return OK instead of BUF_ERROR at next call of deflate:
  982|       |             */
  983|      0|            s->last_flush = -1;
  984|      0|            return Z_OK;
  985|      0|        }
  986|       |
  987|       |    /* Make sure there is something to do and avoid duplicate consecutive
  988|       |     * flushes. For repeated and useless calls with Z_FINISH, we keep
  989|       |     * returning Z_STREAM_END instead of Z_BUF_ERROR.
  990|       |     */
  991|  50.6M|    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
                                                    ^4.31M^4.31M     ^4.31M
  ------------------
  |  Branch (991:16): [True: 4.31M, False: 46.3M]
  |  Branch (991:39): [True: 0, False: 4.31M]
  ------------------
  992|  50.6M|               flush != Z_FINISH) {
                             ^0       ^0
  ------------------
  |  Branch (992:16): [True: 0, False: 0]
  ------------------
  993|      0|        ERR_RETURN(strm, Z_BUF_ERROR);
  994|      0|    }
  995|       |
  996|       |    /* User must not provide more input after the first FINISH: */
  997|  50.6M|    if (s->status == FINISH_STATE && strm->avail_in != 0) {
                                                   ^0
  ------------------
  |  Branch (997:9): [True: 0, False: 50.6M]
  |  Branch (997:38): [True: 0, False: 0]
  ------------------
  998|      0|        ERR_RETURN(strm, Z_BUF_ERROR);
  999|      0|    }
 1000|       |
 1001|       |    /* Write the header */
 1002|  50.6M|    if (s->status == INIT_STATE && s->wrap == 0)
                                                 ^15.9M
  ------------------
  |  Branch (1002:9): [True: 15.9M, False: 34.7M]
  |  Branch (1002:36): [True: 0, False: 15.9M]
  ------------------
 1003|      0|        s->status = BUSY_STATE;
 1004|  50.6M|    if (s->status == INIT_STATE) {
  ------------------
  |  Branch (1004:9): [True: 15.9M, False: 34.7M]
  ------------------
 1005|       |        /* zlib header */
 1006|  15.9M|        uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
 1007|  15.9M|        uInt level_flags;
 1008|       |
 1009|  15.9M|        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
  ------------------
  |  Branch (1009:13): [True: 0, False: 15.9M]
  |  Branch (1009:46): [True: 0, False: 15.9M]
  ------------------
 1010|      0|            level_flags = 0;
 1011|  15.9M|        else if (s->level < 6)
  ------------------
  |  Branch (1011:18): [True: 0, False: 15.9M]
  ------------------
 1012|      0|            level_flags = 1;
 1013|  15.9M|        else if (s->level == 6)
  ------------------
  |  Branch (1013:18): [True: 15.9M, False: 0]
  ------------------
 1014|  15.9M|            level_flags = 2;
 1015|      0|        else
 1016|      0|            level_flags = 3;
 1017|  15.9M|        header |= (level_flags << 6);
 1018|  15.9M|        if (s->strstart != 0) header |= PRESET_DICT;
                                            ^0        ^0
  ------------------
  |  Branch (1018:13): [True: 0, False: 15.9M]
  ------------------
 1019|  15.9M|        header += 31 - (header % 31);
 1020|       |
 1021|  15.9M|        putShortMSB(s, header);
 1022|       |
 1023|       |        /* Save the adler32 of the preset dictionary: */
 1024|  15.9M|        if (s->strstart != 0) {
  ------------------
  |  Branch (1024:13): [True: 0, False: 15.9M]
  ------------------
 1025|      0|            putShortMSB(s, (uInt)(strm->adler >> 16));
 1026|      0|            putShortMSB(s, (uInt)(strm->adler & 0xffff));
 1027|      0|        }
 1028|  15.9M|        strm->adler = adler32(0L, Z_NULL, 0);
 1029|  15.9M|        s->status = BUSY_STATE;
 1030|       |
 1031|       |        /* Compression must start with an empty pending buffer */
 1032|  15.9M|        flush_pending(strm);
 1033|  15.9M|        if (s->pending != 0) {
  ------------------
  |  Branch (1033:13): [True: 0, False: 15.9M]
  ------------------
 1034|      0|            s->last_flush = -1;
 1035|      0|            return Z_OK;
 1036|      0|        }
 1037|  15.9M|    }
 1038|  50.6M|#ifdef GZIP
 1039|  50.6M|    if (s->status == GZIP_STATE) {
  ------------------
  |  Branch (1039:9): [True: 0, False: 50.6M]
  ------------------
 1040|       |        /* gzip header */
 1041|      0|        strm->adler = crc32(0L, Z_NULL, 0);
 1042|      0|        put_byte(s, 31);
 1043|      0|        put_byte(s, 139);
 1044|      0|        put_byte(s, 8);
 1045|      0|        if (s->gzhead == Z_NULL) {
  ------------------
  |  Branch (1045:13): [True: 0, False: 0]
  ------------------
 1046|      0|            put_byte(s, 0);
 1047|      0|            put_byte(s, 0);
 1048|      0|            put_byte(s, 0);
 1049|      0|            put_byte(s, 0);
 1050|      0|            put_byte(s, 0);
 1051|      0|            put_byte(s, s->level == 9 ? 2 :
 1052|      0|                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
 1053|      0|                      4 : 0));
 1054|      0|            put_byte(s, OS_CODE);
 1055|      0|            s->status = BUSY_STATE;
 1056|       |
 1057|       |            /* Compression must start with an empty pending buffer */
 1058|      0|            flush_pending(strm);
 1059|      0|            if (s->pending != 0) {
  ------------------
  |  Branch (1059:17): [True: 0, False: 0]
  ------------------
 1060|      0|                s->last_flush = -1;
 1061|      0|                return Z_OK;
 1062|      0|            }
 1063|      0|        }
 1064|      0|        else {
 1065|      0|            put_byte(s, (s->gzhead->text ? 1 : 0) +
 1066|      0|                     (s->gzhead->hcrc ? 2 : 0) +
 1067|      0|                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
 1068|      0|                     (s->gzhead->name == Z_NULL ? 0 : 8) +
 1069|      0|                     (s->gzhead->comment == Z_NULL ? 0 : 16)
 1070|      0|                     );
 1071|      0|            put_byte(s, (Byte)(s->gzhead->time & 0xff));
 1072|      0|            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
 1073|      0|            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
 1074|      0|            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
 1075|      0|            put_byte(s, s->level == 9 ? 2 :
 1076|      0|                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
 1077|      0|                      4 : 0));
 1078|      0|            put_byte(s, s->gzhead->os & 0xff);
 1079|      0|            if (s->gzhead->extra != Z_NULL) {
  ------------------
  |  Branch (1079:17): [True: 0, False: 0]
  ------------------
 1080|      0|                put_byte(s, s->gzhead->extra_len & 0xff);
 1081|      0|                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
 1082|      0|            }
 1083|      0|            if (s->gzhead->hcrc)
  ------------------
  |  Branch (1083:17): [True: 0, False: 0]
  ------------------
 1084|      0|                strm->adler = crc32(strm->adler, s->pending_buf,
 1085|      0|                                    s->pending);
 1086|      0|            s->gzindex = 0;
 1087|      0|            s->status = EXTRA_STATE;
 1088|      0|        }
 1089|      0|    }
 1090|  50.6M|    if (s->status == EXTRA_STATE) {
  ------------------
  |  Branch (1090:9): [True: 0, False: 50.6M]
  ------------------
 1091|      0|        if (s->gzhead->extra != Z_NULL) {
  ------------------
  |  Branch (1091:13): [True: 0, False: 0]
  ------------------
 1092|      0|            ulg beg = s->pending;   /* start of bytes to update crc */
 1093|      0|            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
 1094|      0|            while (s->pending + left > s->pending_buf_size) {
  ------------------
  |  Branch (1094:20): [True: 0, False: 0]
  ------------------
 1095|      0|                uInt copy = s->pending_buf_size - s->pending;
 1096|      0|                zmemcpy(s->pending_buf + s->pending,
 1097|      0|                        s->gzhead->extra + s->gzindex, copy);
 1098|      0|                s->pending = s->pending_buf_size;
 1099|      0|                HCRC_UPDATE(beg);
 1100|      0|                s->gzindex += copy;
 1101|      0|                flush_pending(strm);
 1102|      0|                if (s->pending != 0) {
  ------------------
  |  Branch (1102:21): [True: 0, False: 0]
  ------------------
 1103|      0|                    s->last_flush = -1;
 1104|      0|                    return Z_OK;
 1105|      0|                }
 1106|      0|                beg = 0;
 1107|      0|                left -= copy;
 1108|      0|            }
 1109|      0|            zmemcpy(s->pending_buf + s->pending,
 1110|      0|                    s->gzhead->extra + s->gzindex, left);
 1111|      0|            s->pending += left;
 1112|      0|            HCRC_UPDATE(beg);
 1113|      0|            s->gzindex = 0;
 1114|      0|        }
 1115|      0|        s->status = NAME_STATE;
 1116|      0|    }
 1117|  50.6M|    if (s->status == NAME_STATE) {
  ------------------
  |  Branch (1117:9): [True: 0, False: 50.6M]
  ------------------
 1118|      0|        if (s->gzhead->name != Z_NULL) {
  ------------------
  |  Branch (1118:13): [True: 0, False: 0]
  ------------------
 1119|      0|            ulg beg = s->pending;   /* start of bytes to update crc */
 1120|      0|            int val;
 1121|      0|            do {
 1122|      0|                if (s->pending == s->pending_buf_size) {
  ------------------
  |  Branch (1122:21): [True: 0, False: 0]
  ------------------
 1123|      0|                    HCRC_UPDATE(beg);
 1124|      0|                    flush_pending(strm);
 1125|      0|                    if (s->pending != 0) {
  ------------------
  |  Branch (1125:25): [True: 0, False: 0]
  ------------------
 1126|      0|                        s->last_flush = -1;
 1127|      0|                        return Z_OK;
 1128|      0|                    }
 1129|      0|                    beg = 0;
 1130|      0|                }
 1131|      0|                val = s->gzhead->name[s->gzindex++];
 1132|      0|                put_byte(s, val);
 1133|      0|            } while (val != 0);
  ------------------
  |  Branch (1133:22): [True: 0, False: 0]
  ------------------
 1134|      0|            HCRC_UPDATE(beg);
 1135|      0|            s->gzindex = 0;
 1136|      0|        }
 1137|      0|        s->status = COMMENT_STATE;
 1138|      0|    }
 1139|  50.6M|    if (s->status == COMMENT_STATE) {
  ------------------
  |  Branch (1139:9): [True: 0, False: 50.6M]
  ------------------
 1140|      0|        if (s->gzhead->comment != Z_NULL) {
  ------------------
  |  Branch (1140:13): [True: 0, False: 0]
  ------------------
 1141|      0|            ulg beg = s->pending;   /* start of bytes to update crc */
 1142|      0|            int val;
 1143|      0|            do {
 1144|      0|                if (s->pending == s->pending_buf_size) {
  ------------------
  |  Branch (1144:21): [True: 0, False: 0]
  ------------------
 1145|      0|                    HCRC_UPDATE(beg);
 1146|      0|                    flush_pending(strm);
 1147|      0|                    if (s->pending != 0) {
  ------------------
  |  Branch (1147:25): [True: 0, False: 0]
  ------------------
 1148|      0|                        s->last_flush = -1;
 1149|      0|                        return Z_OK;
 1150|      0|                    }
 1151|      0|                    beg = 0;
 1152|      0|                }
 1153|      0|                val = s->gzhead->comment[s->gzindex++];
 1154|      0|                put_byte(s, val);
 1155|      0|            } while (val != 0);
  ------------------
  |  Branch (1155:22): [True: 0, False: 0]
  ------------------
 1156|      0|            HCRC_UPDATE(beg);
 1157|      0|        }
 1158|      0|        s->status = HCRC_STATE;
 1159|      0|    }
 1160|  50.6M|    if (s->status == HCRC_STATE) {
  ------------------
  |  Branch (1160:9): [True: 0, False: 50.6M]
  ------------------
 1161|      0|        if (s->gzhead->hcrc) {
  ------------------
  |  Branch (1161:13): [True: 0, False: 0]
  ------------------
 1162|      0|            if (s->pending + 2 > s->pending_buf_size) {
  ------------------
  |  Branch (1162:17): [True: 0, False: 0]
  ------------------
 1163|      0|                flush_pending(strm);
 1164|      0|                if (s->pending != 0) {
  ------------------
  |  Branch (1164:21): [True: 0, False: 0]
  ------------------
 1165|      0|                    s->last_flush = -1;
 1166|      0|                    return Z_OK;
 1167|      0|                }
 1168|      0|            }
 1169|      0|            put_byte(s, (Byte)(strm->adler & 0xff));
 1170|      0|            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
 1171|      0|            strm->adler = crc32(0L, Z_NULL, 0);
 1172|      0|        }
 1173|      0|        s->status = BUSY_STATE;
 1174|       |
 1175|       |        /* Compression must start with an empty pending buffer */
 1176|      0|        flush_pending(strm);
 1177|      0|        if (s->pending != 0) {
  ------------------
  |  Branch (1177:13): [True: 0, False: 0]
  ------------------
 1178|      0|            s->last_flush = -1;
 1179|      0|            return Z_OK;
 1180|      0|        }
 1181|      0|    }
 1182|  50.6M|#endif
 1183|       |
 1184|       |    /* Start a new block or continue the current one.
 1185|       |     */
 1186|  50.6M|    if (strm->avail_in != 0 || s->lookahead != 0 ||
                                             ^4.31M
  ------------------
  |  Branch (1186:9): [True: 46.3M, False: 4.31M]
  |  Branch (1186:32): [True: 4.31M, False: 0]
  ------------------
 1187|  50.6M|        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
                      ^0^0       ^0            ^0           ^0
  ------------------
  |  Branch (1187:10): [True: 0, False: 0]
  |  Branch (1187:33): [True: 0, False: 0]
  ------------------
 1188|  50.6M|        block_state bstate;
 1189|       |
 1190|  50.6M|        bstate = s->level == 0 ? deflate_stored(s, flush) :
                                               ^0
  ------------------
  |  Branch (1190:18): [True: 0, False: 50.6M]
  ------------------
 1191|  50.6M|                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                                                               ^0
  ------------------
  |  Branch (1191:18): [True: 0, False: 50.6M]
  ------------------
 1192|  50.6M|                 s->strategy == Z_RLE ? deflate_rle(s, flush) :
                                                      ^0
  ------------------
  |  Branch (1192:18): [True: 0, False: 50.6M]
  ------------------
 1193|  50.6M|                 (*(configuration_table[s->level].func))(s, flush);
 1194|       |
 1195|  50.6M|        if (bstate == finish_started || bstate == finish_done) {
  ------------------
  |  Branch (1195:13): [True: 0, False: 50.6M]
  |  Branch (1195:41): [True: 15.2M, False: 35.4M]
  ------------------
 1196|  15.2M|            s->status = FINISH_STATE;
 1197|  15.2M|        }
 1198|  50.6M|        if (bstate == need_more || bstate == finish_started) {
                                                 ^28.2M
  ------------------
  |  Branch (1198:13): [True: 22.4M, False: 28.2M]
  |  Branch (1198:36): [True: 0, False: 28.2M]
  ------------------
 1199|  22.4M|            if (strm->avail_out == 0) {
  ------------------
  |  Branch (1199:17): [True: 0, False: 22.4M]
  ------------------
 1200|      0|                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
 1201|      0|            }
 1202|  22.4M|            return Z_OK;
 1203|       |            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
 1204|       |             * of deflate should use the same flush parameter to make sure
 1205|       |             * that the flush is complete. So we don't have to output an
 1206|       |             * empty block here, this will be done at next call. This also
 1207|       |             * ensures that for a very small output buffer, we emit at most
 1208|       |             * one empty block.
 1209|       |             */
 1210|  22.4M|        }
 1211|  28.2M|        if (bstate == block_done) {
  ------------------
  |  Branch (1211:13): [True: 13.0M, False: 15.2M]
  ------------------
 1212|  13.0M|            if (flush == Z_PARTIAL_FLUSH) {
  ------------------
  |  Branch (1212:17): [True: 4.34M, False: 8.66M]
  ------------------
 1213|  4.34M|                _tr_align(s);
 1214|  8.66M|            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
  ------------------
  |  Branch (1214:24): [True: 8.66M, False: 5.36k]
  ------------------
 1215|  8.66M|                _tr_stored_block(s, (char*)0, 0L, 0);
 1216|       |                /* For a full flush, this empty block will be recognized
 1217|       |                 * as a special marker by inflate_sync().
 1218|       |                 */
 1219|  8.66M|                if (flush == Z_FULL_FLUSH) {
  ------------------
  |  Branch (1219:21): [True: 4.32M, False: 4.33M]
  ------------------
 1220|  4.32M|                    CLEAR_HASH(s);             /* forget history */
 1221|  4.32M|                    if (s->lookahead == 0) {
  ------------------
  |  Branch (1221:25): [True: 4.32M, False: 0]
  ------------------
 1222|  4.32M|                        s->strstart = 0;
 1223|  4.32M|                        s->block_start = 0L;
 1224|  4.32M|                        s->insert = 0;
 1225|  4.32M|                    }
 1226|  4.32M|                }
 1227|  8.66M|            }
 1228|  13.0M|            flush_pending(strm);
 1229|  13.0M|            if (strm->avail_out == 0) {
  ------------------
  |  Branch (1229:17): [True: 0, False: 13.0M]
  ------------------
 1230|      0|              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
 1231|      0|              return Z_OK;
 1232|      0|            }
 1233|  13.0M|        }
 1234|  28.2M|    }
 1235|       |
 1236|  28.2M|    if (flush != Z_FINISH) return Z_OK;
                                         ^13.0M ^13.0M
  ------------------
  |  Branch (1236:9): [True: 13.0M, False: 15.2M]
  ------------------
 1237|  15.2M|    if (s->wrap <= 0) return Z_STREAM_END;
                                    ^0     ^0
  ------------------
  |  Branch (1237:9): [True: 0, False: 15.2M]
  ------------------
 1238|       |
 1239|       |    /* Write the trailer */
 1240|  15.2M|#ifdef GZIP
 1241|  15.2M|    if (s->wrap == 2) {
  ------------------
  |  Branch (1241:9): [True: 0, False: 15.2M]
  ------------------
 1242|      0|        put_byte(s, (Byte)(strm->adler & 0xff));
 1243|      0|        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
 1244|      0|        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
 1245|      0|        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
 1246|      0|        put_byte(s, (Byte)(strm->total_in & 0xff));
 1247|      0|        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
 1248|      0|        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
 1249|      0|        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
 1250|      0|    }
 1251|  15.2M|    else
 1252|  15.2M|#endif
 1253|  15.2M|    {
 1254|  15.2M|        putShortMSB(s, (uInt)(strm->adler >> 16));
 1255|  15.2M|        putShortMSB(s, (uInt)(strm->adler & 0xffff));
 1256|  15.2M|    }
 1257|  15.2M|    flush_pending(strm);
 1258|       |    /* If avail_out is zero, the application will call deflate again
 1259|       |     * to flush the rest.
 1260|       |     */
 1261|  15.2M|    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
  ------------------
  |  Branch (1261:9): [True: 15.2M, False: 0]
  ------------------
 1262|  15.2M|    return s->pending != 0 ? Z_OK : Z_STREAM_END;
                                           ^0
  ------------------
  |  Branch (1262:12): [True: 0, False: 15.2M]
  ------------------
 1263|  15.2M|}
 1264|       |
 1265|       |/* ========================================================================= */
 1266|  66.6M|int ZEXPORT deflateEnd(z_streamp strm) {
 1267|  66.6M|    int status;
 1268|       |
 1269|  66.6M|    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
                                               ^0     ^0
  ------------------
  |  Branch (1269:9): [True: 0, False: 66.6M]
  ------------------
 1270|       |
 1271|  66.6M|    status = strm->state->status;
 1272|       |
 1273|       |    /* Deallocate in reverse order of allocations: */
 1274|  66.6M|    TRY_FREE(strm, strm->state->pending_buf);
 1275|  66.6M|    TRY_FREE(strm, strm->state->head);
 1276|  66.6M|    TRY_FREE(strm, strm->state->prev);
 1277|  66.6M|    TRY_FREE(strm, strm->state->window);
 1278|       |
 1279|  66.6M|    ZFREE(strm, strm->state);
 1280|  66.6M|    strm->state = Z_NULL;
 1281|       |
 1282|  66.6M|    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
                                                ^699k          ^65.9M
  ------------------
  |  Branch (1282:12): [True: 699k, False: 65.9M]
  ------------------
 1283|  66.6M|}
 1284|       |
 1285|       |/* =========================================================================
 1286|       | * Copy the source state to the destination state.
 1287|       | * To simplify the source, this is not supported for 16-bit MSDOS (which
 1288|       | * doesn't have enough memory anyway to duplicate compression states).
 1289|       | */
 1290|      0|int ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {
 1291|       |#ifdef MAXSEG_64K
 1292|       |    (void)dest;
 1293|       |    (void)source;
 1294|       |    return Z_STREAM_ERROR;
 1295|       |#else
 1296|      0|    deflate_state *ds;
 1297|      0|    deflate_state *ss;
 1298|       |
 1299|       |
 1300|      0|    if (deflateStateCheck(source) || dest == Z_NULL) {
  ------------------
  |  Branch (1300:9): [True: 0, False: 0]
  |  Branch (1300:38): [True: 0, False: 0]
  ------------------
 1301|      0|        return Z_STREAM_ERROR;
 1302|      0|    }
 1303|       |
 1304|      0|    ss = source->state;
 1305|       |
 1306|      0|    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
 1307|       |
 1308|      0|    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
 1309|      0|    if (ds == Z_NULL) return Z_MEM_ERROR;
  ------------------
  |  Branch (1309:9): [True: 0, False: 0]
  ------------------
 1310|      0|    dest->state = (struct internal_state FAR *) ds;
 1311|      0|    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
 1312|      0|    ds->strm = dest;
 1313|       |
 1314|      0|    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
 1315|      0|    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
 1316|      0|    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
 1317|      0|    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);
 1318|       |
 1319|      0|    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
  ------------------
  |  Branch (1319:9): [True: 0, False: 0]
  |  Branch (1319:33): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|        ds->pending_buf == Z_NULL) {
  ------------------
  |  Branch (1320:9): [True: 0, False: 0]
  ------------------
 1321|      0|        deflateEnd (dest);
 1322|      0|        return Z_MEM_ERROR;
 1323|      0|    }
 1324|       |    /* following zmemcpy do not work for 16-bit MSDOS */
 1325|      0|    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
 1326|      0|    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
 1327|      0|    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
 1328|      0|    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);
 1329|       |
 1330|      0|    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
 1331|       |#ifdef LIT_MEM
 1332|       |    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));
 1333|       |    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);
 1334|       |#else
 1335|      0|    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;
 1336|      0|#endif
 1337|       |
 1338|      0|    ds->l_desc.dyn_tree = ds->dyn_ltree;
 1339|      0|    ds->d_desc.dyn_tree = ds->dyn_dtree;
 1340|      0|    ds->bl_desc.dyn_tree = ds->bl_tree;
 1341|       |
 1342|      0|    return Z_OK;
 1343|      0|#endif /* MAXSEG_64K */
 1344|      0|}
 1345|       |
 1346|       |#ifndef FASTEST
 1347|       |/* ===========================================================================
 1348|       | * Set match_start to the longest match starting at the given string and
 1349|       | * return its length. Matches shorter or equal to prev_length are discarded,
 1350|       | * in which case the result is equal to prev_length and match_start is
 1351|       | * garbage.
 1352|       | * IN assertions: cur_match is the head of the hash chain for the current
 1353|       | *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 1354|       | * OUT assertion: the match length is not greater than s->lookahead.
 1355|       | */
 1356|   169M|local uInt longest_match(deflate_state *s, IPos cur_match) {
 1357|   169M|    unsigned chain_length = s->max_chain_length;/* max hash chain length */
 1358|   169M|    register Bytef *scan = s->window + s->strstart; /* current string */
 1359|   169M|    register Bytef *match;                      /* matched string */
 1360|   169M|    register int len;                           /* length of current match */
 1361|   169M|    int best_len = (int)s->prev_length;         /* best match length so far */
 1362|   169M|    int nice_match = s->nice_match;             /* stop if match long enough */
 1363|   169M|    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
  ------------------
  |  Branch (1363:18): [True: 0, False: 169M]
  ------------------
 1364|   169M|        s->strstart - (IPos)MAX_DIST(s) : NIL;
                      ^0                  ^0
 1365|       |    /* Stop when cur_match becomes <= limit. To simplify the code,
 1366|       |     * we prevent matches with the string of window index 0.
 1367|       |     */
 1368|   169M|    Posf *prev = s->prev;
 1369|   169M|    uInt wmask = s->w_mask;
 1370|       |
 1371|       |#ifdef UNALIGNED_OK
 1372|       |    /* Compare two bytes at a time. Note: this is not always beneficial.
 1373|       |     * Try with and without -DUNALIGNED_OK to check.
 1374|       |     */
 1375|       |    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
 1376|       |    register ush scan_start = *(ushf*)scan;
 1377|       |    register ush scan_end   = *(ushf*)(scan + best_len - 1);
 1378|       |#else
 1379|   169M|    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
 1380|   169M|    register Byte scan_end1  = scan[best_len - 1];
 1381|   169M|    register Byte scan_end   = scan[best_len];
 1382|   169M|#endif
 1383|       |
 1384|       |    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
 1385|       |     * It is easy to get rid of this optimization if necessary.
 1386|       |     */
 1387|   169M|    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
 1388|       |
 1389|       |    /* Do not waste too much time if we already have a good match: */
 1390|   169M|    if (s->prev_length >= s->good_match) {
  ------------------
  |  Branch (1390:9): [True: 22.7M, False: 146M]
  ------------------
 1391|  22.7M|        chain_length >>= 2;
 1392|  22.7M|    }
 1393|       |    /* Do not look for matches beyond the end of the input. This is necessary
 1394|       |     * to make deflate deterministic.
 1395|       |     */
 1396|   169M|    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;
                                                       ^98.5M
  ------------------
  |  Branch (1396:9): [True: 98.5M, False: 71.0M]
  ------------------
 1397|       |
 1398|   169M|    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
 1399|   169M|           "need lookahead");
 1400|       |
 1401|  3.21G|    do {
 1402|  3.21G|        Assert(cur_match < s->strstart, "no future");
 1403|  3.21G|        match = s->window + cur_match;
 1404|       |
 1405|       |        /* Skip to next match if the match length cannot increase
 1406|       |         * or if the match length is less than 2.  Note that the checks below
 1407|       |         * for insufficient lookahead only occur occasionally for performance
 1408|       |         * reasons.  Therefore uninitialized memory will be accessed, and
 1409|       |         * conditional jumps will be made that depend on those values.
 1410|       |         * However the length of the match is limited to the lookahead, so
 1411|       |         * the output of deflate is not affected by the uninitialized values.
 1412|       |         */
 1413|       |#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
 1414|       |        /* This code assumes sizeof(unsigned short) == 2. Do not use
 1415|       |         * UNALIGNED_OK if your compiler uses a different size.
 1416|       |         */
 1417|       |        if (*(ushf*)(match + best_len - 1) != scan_end ||
 1418|       |            *(ushf*)match != scan_start) continue;
 1419|       |
 1420|       |        /* It is not necessary to compare scan[2] and match[2] since they are
 1421|       |         * always equal when the other bytes match, given that the hash keys
 1422|       |         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
 1423|       |         * strstart + 3, + 5, up to strstart + 257. We check for insufficient
 1424|       |         * lookahead only every 4th comparison; the 128th check will be made
 1425|       |         * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is
 1426|       |         * necessary to put more guard bytes at the end of the window, or
 1427|       |         * to check more often for insufficient lookahead.
 1428|       |         */
 1429|       |        Assert(scan[2] == match[2], "scan[2]?");
 1430|       |        scan++, match++;
 1431|       |        do {
 1432|       |        } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
 1433|       |                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
 1434|       |                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
 1435|       |                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
 1436|       |                 scan < strend);
 1437|       |        /* The funny "do {}" generates better code on most compilers */
 1438|       |
 1439|       |        /* Here, scan <= window + strstart + 257 */
 1440|       |        Assert(scan <= s->window + (unsigned)(s->window_size - 1),
 1441|       |               "wild scan");
 1442|       |        if (*scan == *match) scan++;
 1443|       |
 1444|       |        len = (MAX_MATCH - 1) - (int)(strend - scan);
 1445|       |        scan = strend - (MAX_MATCH-1);
 1446|       |
 1447|       |#else /* UNALIGNED_OK */
 1448|       |
 1449|  3.21G|        if (match[best_len]     != scan_end  ||
  ------------------
  |  Branch (1449:13): [True: 1.92G, False: 1.28G]
  ------------------
 1450|  3.21G|            match[best_len - 1] != scan_end1 ||
                          ^1.28G
  ------------------
  |  Branch (1450:13): [True: 215M, False: 1.06G]
  ------------------
 1451|  3.21G|            *match              != *scan     ||
                          ^1.06G
  ------------------
  |  Branch (1451:13): [True: 311M, False: 757M]
  ------------------
 1452|  3.21G|            *++match            != scan[1])      continue;
                          ^757M                                ^2.45G
  ------------------
  |  Branch (1452:13): [True: 1.08k, False: 757M]
  ------------------
 1453|       |
 1454|       |        /* The check at best_len - 1 can be removed because it will be made
 1455|       |         * again later. (This heuristic is not always a win.)
 1456|       |         * It is not necessary to compare scan[2] and match[2] since they
 1457|       |         * are always equal when the other bytes match, given that
 1458|       |         * the hash keys are equal and that HASH_BITS >= 8.
 1459|       |         */
 1460|   757M|        scan += 2, match++;
 1461|   757M|        Assert(*scan == *match, "match[2]?");
 1462|       |
 1463|       |        /* We check for insufficient lookahead only every 8th comparison;
 1464|       |         * the 256th check will be made at strstart + 258.
 1465|       |         */
 1466|  2.48G|        do {
 1467|  2.48G|        } while (*++scan == *++match && *++scan == *++match &&
                                                      ^2.35G
  ------------------
  |  Branch (1467:18): [True: 2.35G, False: 137M]
  |  Branch (1467:41): [True: 2.23G, False: 119M]
  ------------------
 1468|  2.48G|                 *++scan == *++match && *++scan == *++match &&
                               ^2.23G                 ^2.13G
  ------------------
  |  Branch (1468:18): [True: 2.13G, False: 99.0M]
  |  Branch (1468:41): [True: 2.03G, False: 94.0M]
  ------------------
 1469|  2.48G|                 *++scan == *++match && *++scan == *++match &&
                               ^2.03G                 ^1.95G
  ------------------
  |  Branch (1469:18): [True: 1.95G, False: 85.0M]
  |  Branch (1469:41): [True: 1.87G, False: 77.9M]
  ------------------
 1470|  2.48G|                 *++scan == *++match && *++scan == *++match &&
                               ^1.87G                 ^1.80G
  ------------------
  |  Branch (1470:18): [True: 1.80G, False: 74.3M]
  |  Branch (1470:41): [True: 1.73G, False: 68.4M]
  ------------------
 1471|  2.48G|                 scan < strend);
                               ^1.73G
  ------------------
  |  Branch (1471:18): [True: 1.73G, False: 1.69M]
  ------------------
 1472|       |
 1473|   757M|        Assert(scan <= s->window + (unsigned)(s->window_size - 1),
 1474|   757M|               "wild scan");
 1475|       |
 1476|   757M|        len = MAX_MATCH - (int)(strend - scan);
 1477|   757M|        scan = strend - MAX_MATCH;
 1478|       |
 1479|   757M|#endif /* UNALIGNED_OK */
 1480|       |
 1481|   757M|        if (len > best_len) {
  ------------------
  |  Branch (1481:13): [True: 655M, False: 102M]
  ------------------
 1482|   655M|            s->match_start = cur_match;
 1483|   655M|            best_len = len;
 1484|   655M|            if (len >= nice_match) break;
                                                 ^17.5M
  ------------------
  |  Branch (1484:17): [True: 17.5M, False: 637M]
  ------------------
 1485|       |#ifdef UNALIGNED_OK
 1486|       |            scan_end = *(ushf*)(scan + best_len - 1);
 1487|       |#else
 1488|   637M|            scan_end1  = scan[best_len - 1];
 1489|   637M|            scan_end   = scan[best_len];
 1490|   637M|#endif
 1491|   637M|        }
 1492|  3.19G|    } while ((cur_match = prev[cur_match & wmask]) > limit
  ------------------
  |  Branch (1492:14): [True: 3.05G, False: 139M]
  ------------------
 1493|  3.19G|             && --chain_length != 0);
                              ^3.05G
  ------------------
  |  Branch (1493:17): [True: 3.04G, False: 12.9M]
  ------------------
 1494|       |
 1495|   169M|    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
                                                      ^160M
  ------------------
  |  Branch (1495:9): [True: 160M, False: 8.89M]
  ------------------
 1496|  8.89M|    return s->lookahead;
 1497|   169M|}
 1498|       |
 1499|       |#else /* FASTEST */
 1500|       |
 1501|       |/* ---------------------------------------------------------------------------
 1502|       | * Optimized version for FASTEST only
 1503|       | */
 1504|       |local uInt longest_match(deflate_state *s, IPos cur_match) {
 1505|       |    register Bytef *scan = s->window + s->strstart; /* current string */
 1506|       |    register Bytef *match;                       /* matched string */
 1507|       |    register int len;                           /* length of current match */
 1508|       |    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
 1509|       |
 1510|       |    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
 1511|       |     * It is easy to get rid of this optimization if necessary.
 1512|       |     */
 1513|       |    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
 1514|       |
 1515|       |    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
 1516|       |           "need lookahead");
 1517|       |
 1518|       |    Assert(cur_match < s->strstart, "no future");
 1519|       |
 1520|       |    match = s->window + cur_match;
 1521|       |
 1522|       |    /* Return failure if the match length is less than 2:
 1523|       |     */
 1524|       |    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
 1525|       |
 1526|       |    /* The check at best_len - 1 can be removed because it will be made
 1527|       |     * again later. (This heuristic is not always a win.)
 1528|       |     * It is not necessary to compare scan[2] and match[2] since they
 1529|       |     * are always equal when the other bytes match, given that
 1530|       |     * the hash keys are equal and that HASH_BITS >= 8.
 1531|       |     */
 1532|       |    scan += 2, match += 2;
 1533|       |    Assert(*scan == *match, "match[2]?");
 1534|       |
 1535|       |    /* We check for insufficient lookahead only every 8th comparison;
 1536|       |     * the 256th check will be made at strstart + 258.
 1537|       |     */
 1538|       |    do {
 1539|       |    } while (*++scan == *++match && *++scan == *++match &&
 1540|       |             *++scan == *++match && *++scan == *++match &&
 1541|       |             *++scan == *++match && *++scan == *++match &&
 1542|       |             *++scan == *++match && *++scan == *++match &&
 1543|       |             scan < strend);
 1544|       |
 1545|       |    Assert(scan <= s->window + (unsigned)(s->window_size - 1), "wild scan");
 1546|       |
 1547|       |    len = MAX_MATCH - (int)(strend - scan);
 1548|       |
 1549|       |    if (len < MIN_MATCH) return MIN_MATCH - 1;
 1550|       |
 1551|       |    s->match_start = cur_match;
 1552|       |    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
 1553|       |}
 1554|       |
 1555|       |#endif /* FASTEST */
 1556|       |
 1557|       |#ifdef ZLIB_DEBUG
 1558|       |
 1559|       |#define EQUAL 0
 1560|       |/* result of memcmp for equal strings */
 1561|       |
 1562|       |/* ===========================================================================
 1563|       | * Check that the match at match_start is indeed a match.
 1564|       | */
 1565|       |local void check_match(deflate_state *s, IPos start, IPos match, int length) {
 1566|       |    /* check that the match is indeed a match */
 1567|       |    Bytef *back = s->window + (int)match, *here = s->window + start;
 1568|       |    IPos len = length;
 1569|       |    if (match == (IPos)-1) {
 1570|       |        /* match starts one byte before the current window -- just compare the
 1571|       |           subsequent length-1 bytes */
 1572|       |        back++;
 1573|       |        here++;
 1574|       |        len--;
 1575|       |    }
 1576|       |    if (zmemcmp(back, here, len) != EQUAL) {
 1577|       |        fprintf(stderr, " start %u, match %d, length %d\n",
 1578|       |                start, (int)match, length);
 1579|       |        do {
 1580|       |            fprintf(stderr, "(%02x %02x)", *back++, *here++);
 1581|       |        } while (--len != 0);
 1582|       |        z_error("invalid match");
 1583|       |    }
 1584|       |    if (z_verbose > 1) {
 1585|       |        fprintf(stderr,"\\[%d,%d]", start - match, length);
 1586|       |        do { putc(s->window[start++], stderr); } while (--length != 0);
 1587|       |    }
 1588|       |}
 1589|       |#else
 1590|       |#  define check_match(s, start, match, length)
 1591|       |#endif /* ZLIB_DEBUG */
 1592|       |
 1593|       |/* ===========================================================================
 1594|       | * Flush the current block, with given end-of-file flag.
 1595|       | * IN assertion: strstart is set to the end of the current match.
 1596|       | */
 1597|  28.2M|#define FLUSH_BLOCK_ONLY(s, last) { \
 1598|  28.2M|   _tr_flush_block(s, (s->block_start >= 0L ? \
 1599|  28.2M|                   (charf *)&s->window[(unsigned)s->block_start] : \
 1600|  28.2M|                   (charf *)Z_NULL), \
                                 ^0       ^0
 1601|  28.2M|                (ulg)((long)s->strstart - s->block_start), \
 1602|  28.2M|                (last)); \
 1603|  28.2M|   s->block_start = s->strstart; \
 1604|  28.2M|   flush_pending(s->strm); \
 1605|  28.2M|   Tracev((stderr,"[FLUSH]")); \
 1606|  28.2M|}
 1607|       |
 1608|       |/* Same but force premature exit if necessary. */
 1609|  28.2M|#define FLUSH_BLOCK(s, last) { \
 1610|  28.2M|   FLUSH_BLOCK_ONLY(s, last); \
 1611|  28.2M|   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
                                              ^0     ^0       ^0               ^0
 1612|  28.2M|}
 1613|       |
 1614|       |/* Maximum stored block length in deflate format (not including header). */
 1615|      0|#define MAX_STORED 65535
 1616|       |
 1617|       |/* Minimum of a and b. */
 1618|      0|#define MIN(a, b) ((a) > (b) ? (b) : (a))
 1619|       |
 1620|       |/* ===========================================================================
 1621|       | * Copy without compression as much as possible from the input stream, return
 1622|       | * the current block state.
 1623|       | *
 1624|       | * In case deflateParams() is used to later switch to a non-zero compression
 1625|       | * level, s->matches (otherwise unused when storing) keeps track of the number
 1626|       | * of hash table slides to perform. If s->matches is 1, then one hash table
 1627|       | * slide will be done when switching. If s->matches is 2, the maximum value
 1628|       | * allowed here, then the hash table will be cleared, since two or more slides
 1629|       | * is the same as a clear.
 1630|       | *
 1631|       | * deflate_stored() is written to minimize the number of times an input byte is
 1632|       | * copied. It is most efficient with large input and output buffers, which
 1633|       | * maximizes the opportunities to have a single copy from next_in to next_out.
 1634|       | */
 1635|      0|local block_state deflate_stored(deflate_state *s, int flush) {
 1636|       |    /* Smallest worthy block size when not flushing or finishing. By default
 1637|       |     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
 1638|       |     * large input and output buffers, the stored block size will be larger.
 1639|       |     */
 1640|      0|    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
 1641|       |
 1642|       |    /* Copy as many min_block or larger stored blocks directly to next_out as
 1643|       |     * possible. If flushing, copy the remaining available input to next_out as
 1644|       |     * stored blocks, if there is enough space.
 1645|       |     */
 1646|      0|    int last = 0;
 1647|      0|    unsigned len, left, have;
 1648|      0|    unsigned used = s->strm->avail_in;
 1649|      0|    do {
 1650|       |        /* Set len to the maximum size block that we can copy directly with the
 1651|       |         * available input data and output space. Set left to how much of that
 1652|       |         * would be copied from what's left in the window.
 1653|       |         */
 1654|      0|        len = MAX_STORED;       /* maximum deflate stored block length */
 1655|      0|        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
 1656|      0|        if (s->strm->avail_out < have)          /* need room for header */
  ------------------
  |  Branch (1656:13): [True: 0, False: 0]
  ------------------
 1657|      0|            break;
 1658|       |            /* maximum stored block length that will fit in avail_out: */
 1659|      0|        have = s->strm->avail_out - have;
 1660|      0|        left = s->strstart - s->block_start;    /* bytes left in window */
 1661|      0|        if (len > (ulg)left + s->strm->avail_in)
  ------------------
  |  Branch (1661:13): [True: 0, False: 0]
  ------------------
 1662|      0|            len = left + s->strm->avail_in;     /* limit len to the input */
 1663|      0|        if (len > have)
  ------------------
  |  Branch (1663:13): [True: 0, False: 0]
  ------------------
 1664|      0|            len = have;                         /* limit len to the output */
 1665|       |
 1666|       |        /* If the stored block would be less than min_block in length, or if
 1667|       |         * unable to copy all of the available input when flushing, then try
 1668|       |         * copying to the window and the pending buffer instead. Also don't
 1669|       |         * write an empty block when flushing -- deflate() does that.
 1670|       |         */
 1671|      0|        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
  ------------------
  |  Branch (1671:13): [True: 0, False: 0]
  |  Branch (1671:34): [True: 0, False: 0]
  |  Branch (1671:46): [True: 0, False: 0]
  ------------------
 1672|      0|                                flush == Z_NO_FLUSH ||
  ------------------
  |  Branch (1672:33): [True: 0, False: 0]
  ------------------
 1673|      0|                                len != left + s->strm->avail_in))
  ------------------
  |  Branch (1673:33): [True: 0, False: 0]
  ------------------
 1674|      0|            break;
 1675|       |
 1676|       |        /* Make a dummy stored block in pending to get the header bytes,
 1677|       |         * including any pending bits. This also updates the debugging counts.
 1678|       |         */
 1679|      0|        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
  ------------------
  |  Branch (1679:16): [True: 0, False: 0]
  |  Branch (1679:37): [True: 0, False: 0]
  ------------------
 1680|      0|        _tr_stored_block(s, (char *)0, 0L, last);
 1681|       |
 1682|       |        /* Replace the lengths in the dummy stored block with len. */
 1683|      0|        s->pending_buf[s->pending - 4] = (Bytef)len;
 1684|      0|        s->pending_buf[s->pending - 3] = (Bytef)(len >> 8);
 1685|      0|        s->pending_buf[s->pending - 2] = (Bytef)~len;
 1686|      0|        s->pending_buf[s->pending - 1] = (Bytef)(~len >> 8);
 1687|       |
 1688|       |        /* Write the stored block header bytes. */
 1689|      0|        flush_pending(s->strm);
 1690|       |
 1691|       |#ifdef ZLIB_DEBUG
 1692|       |        /* Update debugging counts for the data about to be copied. */
 1693|       |        s->compressed_len += len << 3;
 1694|       |        s->bits_sent += len << 3;
 1695|       |#endif
 1696|       |
 1697|       |        /* Copy uncompressed bytes from the window to next_out. */
 1698|      0|        if (left) {
  ------------------
  |  Branch (1698:13): [True: 0, False: 0]
  ------------------
 1699|      0|            if (left > len)
  ------------------
  |  Branch (1699:17): [True: 0, False: 0]
  ------------------
 1700|      0|                left = len;
 1701|      0|            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
 1702|      0|            s->strm->next_out += left;
 1703|      0|            s->strm->avail_out -= left;
 1704|      0|            s->strm->total_out += left;
 1705|      0|            s->block_start += left;
 1706|      0|            len -= left;
 1707|      0|        }
 1708|       |
 1709|       |        /* Copy uncompressed bytes directly from next_in to next_out, updating
 1710|       |         * the check value.
 1711|       |         */
 1712|      0|        if (len) {
  ------------------
  |  Branch (1712:13): [True: 0, False: 0]
  ------------------
 1713|      0|            read_buf(s->strm, s->strm->next_out, len);
 1714|      0|            s->strm->next_out += len;
 1715|      0|            s->strm->avail_out -= len;
 1716|      0|            s->strm->total_out += len;
 1717|      0|        }
 1718|      0|    } while (last == 0);
  ------------------
  |  Branch (1718:14): [True: 0, False: 0]
  ------------------
 1719|       |
 1720|       |    /* Update the sliding window with the last s->w_size bytes of the copied
 1721|       |     * data, or append all of the copied data to the existing window if less
 1722|       |     * than s->w_size bytes were copied. Also update the number of bytes to
 1723|       |     * insert in the hash tables, in the event that deflateParams() switches to
 1724|       |     * a non-zero compression level.
 1725|       |     */
 1726|      0|    used -= s->strm->avail_in;      /* number of input bytes directly copied */
 1727|      0|    if (used) {
  ------------------
  |  Branch (1727:9): [True: 0, False: 0]
  ------------------
 1728|       |        /* If any input was used, then no unused input remains in the window,
 1729|       |         * therefore s->block_start == s->strstart.
 1730|       |         */
 1731|      0|        if (used >= s->w_size) {    /* supplant the previous history */
  ------------------
  |  Branch (1731:13): [True: 0, False: 0]
  ------------------
 1732|      0|            s->matches = 2;         /* clear hash */
 1733|      0|            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
 1734|      0|            s->strstart = s->w_size;
 1735|      0|            s->insert = s->strstart;
 1736|      0|        }
 1737|      0|        else {
 1738|      0|            if (s->window_size - s->strstart <= used) {
  ------------------
  |  Branch (1738:17): [True: 0, False: 0]
  ------------------
 1739|       |                /* Slide the window down. */
 1740|      0|                s->strstart -= s->w_size;
 1741|      0|                zmemcpy(s->window, s->window + s->w_size, s->strstart);
 1742|      0|                if (s->matches < 2)
  ------------------
  |  Branch (1742:21): [True: 0, False: 0]
  ------------------
 1743|      0|                    s->matches++;   /* add a pending slide_hash() */
 1744|      0|                if (s->insert > s->strstart)
  ------------------
  |  Branch (1744:21): [True: 0, False: 0]
  ------------------
 1745|      0|                    s->insert = s->strstart;
 1746|      0|            }
 1747|      0|            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
 1748|      0|            s->strstart += used;
 1749|      0|            s->insert += MIN(used, s->w_size - s->insert);
 1750|      0|        }
 1751|      0|        s->block_start = s->strstart;
 1752|      0|    }
 1753|      0|    if (s->high_water < s->strstart)
  ------------------
  |  Branch (1753:9): [True: 0, False: 0]
  ------------------
 1754|      0|        s->high_water = s->strstart;
 1755|       |
 1756|       |    /* If the last block was written to next_out, then done. */
 1757|      0|    if (last) {
  ------------------
  |  Branch (1757:9): [True: 0, False: 0]
  ------------------
 1758|      0|        s->bi_used = 8;
 1759|      0|        return finish_done;
 1760|      0|    }
 1761|       |
 1762|       |    /* If flushing and all input has been consumed, then done. */
 1763|      0|    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
  ------------------
  |  Branch (1763:9): [True: 0, False: 0]
  |  Branch (1763:32): [True: 0, False: 0]
  ------------------
 1764|      0|        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
  ------------------
  |  Branch (1764:9): [True: 0, False: 0]
  |  Branch (1764:35): [True: 0, False: 0]
  ------------------
 1765|      0|        return block_done;
 1766|       |
 1767|       |    /* Fill the window with any remaining input. */
 1768|      0|    have = s->window_size - s->strstart;
 1769|      0|    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
  ------------------
  |  Branch (1769:9): [True: 0, False: 0]
  |  Branch (1769:37): [True: 0, False: 0]
  ------------------
 1770|       |        /* Slide the window down. */
 1771|      0|        s->block_start -= s->w_size;
 1772|      0|        s->strstart -= s->w_size;
 1773|      0|        zmemcpy(s->window, s->window + s->w_size, s->strstart);
 1774|      0|        if (s->matches < 2)
  ------------------
  |  Branch (1774:13): [True: 0, False: 0]
  ------------------
 1775|      0|            s->matches++;           /* add a pending slide_hash() */
 1776|      0|        have += s->w_size;          /* more space now */
 1777|      0|        if (s->insert > s->strstart)
  ------------------
  |  Branch (1777:13): [True: 0, False: 0]
  ------------------
 1778|      0|            s->insert = s->strstart;
 1779|      0|    }
 1780|      0|    if (have > s->strm->avail_in)
  ------------------
  |  Branch (1780:9): [True: 0, False: 0]
  ------------------
 1781|      0|        have = s->strm->avail_in;
 1782|      0|    if (have) {
  ------------------
  |  Branch (1782:9): [True: 0, False: 0]
  ------------------
 1783|      0|        read_buf(s->strm, s->window + s->strstart, have);
 1784|      0|        s->strstart += have;
 1785|      0|        s->insert += MIN(have, s->w_size - s->insert);
 1786|      0|    }
 1787|      0|    if (s->high_water < s->strstart)
  ------------------
  |  Branch (1787:9): [True: 0, False: 0]
  ------------------
 1788|      0|        s->high_water = s->strstart;
 1789|       |
 1790|       |    /* There was not enough avail_out to write a complete worthy or flushed
 1791|       |     * stored block to next_out. Write a stored block to pending instead, if we
 1792|       |     * have enough input for a worthy block, or if flushing and there is enough
 1793|       |     * room for the remaining input as a stored block in the pending buffer.
 1794|       |     */
 1795|      0|    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
 1796|       |        /* maximum stored block length that will fit in pending: */
 1797|      0|    have = MIN(s->pending_buf_size - have, MAX_STORED);
 1798|      0|    min_block = MIN(have, s->w_size);
 1799|      0|    left = s->strstart - s->block_start;
 1800|      0|    if (left >= min_block ||
  ------------------
  |  Branch (1800:9): [True: 0, False: 0]
  ------------------
 1801|      0|        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
  ------------------
  |  Branch (1801:11): [True: 0, False: 0]
  |  Branch (1801:19): [True: 0, False: 0]
  |  Branch (1801:41): [True: 0, False: 0]
  ------------------
 1802|      0|         s->strm->avail_in == 0 && left <= have)) {
  ------------------
  |  Branch (1802:10): [True: 0, False: 0]
  |  Branch (1802:36): [True: 0, False: 0]
  ------------------
 1803|      0|        len = MIN(left, have);
 1804|      0|        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
  ------------------
  |  Branch (1804:16): [True: 0, False: 0]
  |  Branch (1804:37): [True: 0, False: 0]
  ------------------
 1805|      0|               len == left ? 1 : 0;
  ------------------
  |  Branch (1805:16): [True: 0, False: 0]
  ------------------
 1806|      0|        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
 1807|      0|        s->block_start += len;
 1808|      0|        flush_pending(s->strm);
 1809|      0|    }
 1810|       |
 1811|       |    /* We've done all we can with the available input and output. */
 1812|      0|    if (last)
  ------------------
  |  Branch (1812:9): [True: 0, False: 0]
  ------------------
 1813|      0|        s->bi_used = 8;
 1814|      0|    return last ? finish_started : need_more;
  ------------------
  |  Branch (1814:12): [True: 0, False: 0]
  ------------------
 1815|      0|}
 1816|       |
 1817|       |/* ===========================================================================
 1818|       | * Compress as much as possible from the input stream, return the current
 1819|       | * block state.
 1820|       | * This function does not perform lazy evaluation of matches and inserts
 1821|       | * new strings in the dictionary only for unmatched strings or for short
 1822|       | * matches. It is used only for the fast compression options.
 1823|       | */
 1824|      0|local block_state deflate_fast(deflate_state *s, int flush) {
 1825|      0|    IPos hash_head;       /* head of the hash chain */
 1826|      0|    int bflush;           /* set if current block must be flushed */
 1827|       |
 1828|      0|    for (;;) {
 1829|       |        /* Make sure that we always have enough lookahead, except
 1830|       |         * at the end of the input file. We need MAX_MATCH bytes
 1831|       |         * for the next match, plus MIN_MATCH bytes to insert the
 1832|       |         * string following the next match.
 1833|       |         */
 1834|      0|        if (s->lookahead < MIN_LOOKAHEAD) {
  ------------------
  |  Branch (1834:13): [True: 0, False: 0]
  ------------------
 1835|      0|            fill_window(s);
 1836|      0|            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
  ------------------
  |  Branch (1836:17): [True: 0, False: 0]
  |  Branch (1836:49): [True: 0, False: 0]
  ------------------
 1837|      0|                return need_more;
 1838|      0|            }
 1839|      0|            if (s->lookahead == 0) break; /* flush the current block */
  ------------------
  |  Branch (1839:17): [True: 0, False: 0]
  ------------------
 1840|      0|        }
 1841|       |
 1842|       |        /* Insert the string window[strstart .. strstart + 2] in the
 1843|       |         * dictionary, and set hash_head to the head of the hash chain:
 1844|       |         */
 1845|      0|        hash_head = NIL;
 1846|      0|        if (s->lookahead >= MIN_MATCH) {
  ------------------
  |  Branch (1846:13): [True: 0, False: 0]
  ------------------
 1847|      0|            INSERT_STRING(s, s->strstart, hash_head);
 1848|      0|        }
 1849|       |
 1850|       |        /* Find the longest match, discarding those <= prev_length.
 1851|       |         * At this point we have always match_length < MIN_MATCH
 1852|       |         */
 1853|      0|        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
  ------------------
  |  Branch (1853:13): [True: 0, False: 0]
  |  Branch (1853:33): [True: 0, False: 0]
  ------------------
 1854|       |            /* To simplify the code, we prevent matches with the string
 1855|       |             * of window index 0 (in particular we have to avoid a match
 1856|       |             * of the string with itself at the start of the input file).
 1857|       |             */
 1858|      0|            s->match_length = longest_match (s, hash_head);
 1859|       |            /* longest_match() sets match_start */
 1860|      0|        }
 1861|      0|        if (s->match_length >= MIN_MATCH) {
  ------------------
  |  Branch (1861:13): [True: 0, False: 0]
  ------------------
 1862|      0|            check_match(s, s->strstart, s->match_start, s->match_length);
 1863|       |
 1864|      0|            _tr_tally_dist(s, s->strstart - s->match_start,
 1865|      0|                           s->match_length - MIN_MATCH, bflush);
 1866|       |
 1867|      0|            s->lookahead -= s->match_length;
 1868|       |
 1869|       |            /* Insert new strings in the hash table only if the match length
 1870|       |             * is not too large. This saves time but degrades compression.
 1871|       |             */
 1872|      0|#ifndef FASTEST
 1873|      0|            if (s->match_length <= s->max_insert_length &&
  ------------------
  |  Branch (1873:17): [True: 0, False: 0]
  ------------------
 1874|      0|                s->lookahead >= MIN_MATCH) {
  ------------------
  |  Branch (1874:17): [True: 0, False: 0]
  ------------------
 1875|      0|                s->match_length--; /* string at strstart already in table */
 1876|      0|                do {
 1877|      0|                    s->strstart++;
 1878|      0|                    INSERT_STRING(s, s->strstart, hash_head);
 1879|       |                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
 1880|       |                     * always MIN_MATCH bytes ahead.
 1881|       |                     */
 1882|      0|                } while (--s->match_length != 0);
  ------------------
  |  Branch (1882:26): [True: 0, False: 0]
  ------------------
 1883|      0|                s->strstart++;
 1884|      0|            } else
 1885|      0|#endif
 1886|      0|            {
 1887|      0|                s->strstart += s->match_length;
 1888|      0|                s->match_length = 0;
 1889|      0|                s->ins_h = s->window[s->strstart];
 1890|      0|                UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
 1891|       |#if MIN_MATCH != 3
 1892|       |                Call UPDATE_HASH() MIN_MATCH-3 more times
 1893|       |#endif
 1894|       |                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
 1895|       |                 * matter since it will be recomputed at next deflate call.
 1896|       |                 */
 1897|      0|            }
 1898|      0|        } else {
 1899|       |            /* No match, output a literal byte */
 1900|      0|            Tracevv((stderr,"%c", s->window[s->strstart]));
 1901|      0|            _tr_tally_lit(s, s->window[s->strstart], bflush);
 1902|      0|            s->lookahead--;
 1903|      0|            s->strstart++;
 1904|      0|        }
 1905|      0|        if (bflush) FLUSH_BLOCK(s, 0);
  ------------------
  |  Branch (1905:13): [True: 0, False: 0]
  ------------------
 1906|      0|    }
 1907|      0|    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
  ------------------
  |  Branch (1907:17): [True: 0, False: 0]
  ------------------
 1908|      0|    if (flush == Z_FINISH) {
  ------------------
  |  Branch (1908:9): [True: 0, False: 0]
  ------------------
 1909|      0|        FLUSH_BLOCK(s, 1);
 1910|      0|        return finish_done;
 1911|      0|    }
 1912|      0|    if (s->sym_next)
  ------------------
  |  Branch (1912:9): [True: 0, False: 0]
  ------------------
 1913|      0|        FLUSH_BLOCK(s, 0);
 1914|      0|    return block_done;
 1915|      0|}
 1916|       |
 1917|       |#ifndef FASTEST
 1918|       |/* ===========================================================================
 1919|       | * Same as above, but achieves better compression. We use a lazy
 1920|       | * evaluation for matches: a match is finally adopted only if there is
 1921|       | * no better match at the next window position.
 1922|       | */
 1923|  50.6M|local block_state deflate_slow(deflate_state *s, int flush) {
 1924|  50.6M|    IPos hash_head;          /* head of hash chain */
 1925|  50.6M|    int bflush;              /* set if current block must be flushed */
 1926|       |
 1927|       |    /* Process the input block. */
 1928|   496M|    for (;;) {
 1929|       |        /* Make sure that we always have enough lookahead, except
 1930|       |         * at the end of the input file. We need MAX_MATCH bytes
 1931|       |         * for the next match, plus MIN_MATCH bytes to insert the
 1932|       |         * string following the next match.
 1933|       |         */
 1934|   496M|        if (s->lookahead < MIN_LOOKAHEAD) {
  ------------------
  |  Branch (1934:13): [True: 477M, False: 18.6M]
  ------------------
 1935|   477M|            fill_window(s);
 1936|   477M|            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                                                              ^475M    ^475M
  ------------------
  |  Branch (1936:17): [True: 475M, False: 1.96M]
  |  Branch (1936:49): [True: 22.4M, False: 453M]
  ------------------
 1937|  22.4M|                return need_more;
 1938|  22.4M|            }
 1939|   455M|            if (s->lookahead == 0) break; /* flush the current block */
                                                 ^28.2M
  ------------------
  |  Branch (1939:17): [True: 28.2M, False: 427M]
  ------------------
 1940|   455M|        }
 1941|       |
 1942|       |        /* Insert the string window[strstart .. strstart + 2] in the
 1943|       |         * dictionary, and set hash_head to the head of the hash chain:
 1944|       |         */
 1945|   445M|        hash_head = NIL;
 1946|   445M|        if (s->lookahead >= MIN_MATCH) {
  ------------------
  |  Branch (1946:13): [True: 421M, False: 24.4M]
  ------------------
 1947|   421M|            INSERT_STRING(s, s->strstart, hash_head);
 1948|   421M|        }
 1949|       |
 1950|       |        /* Find the longest match, discarding those <= prev_length.
 1951|       |         */
 1952|   445M|        s->prev_length = s->match_length, s->prev_match = s->match_start;
 1953|   445M|        s->match_length = MIN_MATCH-1;
 1954|       |
 1955|   445M|        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
                                              ^208M
  ------------------
  |  Branch (1955:13): [True: 208M, False: 237M]
  |  Branch (1955:33): [True: 169M, False: 38.8M]
  ------------------
 1956|   445M|            s->strstart - hash_head <= MAX_DIST(s)) {
                          ^169M                      ^169M
  ------------------
  |  Branch (1956:13): [True: 169M, False: 0]
  ------------------
 1957|       |            /* To simplify the code, we prevent matches with the string
 1958|       |             * of window index 0 (in particular we have to avoid a match
 1959|       |             * of the string with itself at the start of the input file).
 1960|       |             */
 1961|   169M|            s->match_length = longest_match (s, hash_head);
 1962|       |            /* longest_match() sets match_start */
 1963|       |
 1964|   169M|            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
                                                      ^66.6M^66.6M         ^66.6M
  ------------------
  |  Branch (1964:17): [True: 66.6M, False: 102M]
  |  Branch (1964:42): [True: 0, False: 66.6M]
  ------------------
 1965|  66.6M|#if TOO_FAR <= 32767
 1966|  66.6M|                || (s->match_length == MIN_MATCH &&
  ------------------
  |  Branch (1966:21): [True: 19.3M, False: 47.3M]
  ------------------
 1967|  66.6M|                    s->strstart - s->match_start > TOO_FAR)
                                  ^19.3M                         ^19.3M
  ------------------
  |  Branch (1967:21): [True: 0, False: 19.3M]
  ------------------
 1968|  66.6M|#endif
 1969|  66.6M|                )) {
 1970|       |
 1971|       |                /* If prev_match is also MIN_MATCH, match_start is garbage
 1972|       |                 * but we will ignore the current match anyway.
 1973|       |                 */
 1974|      0|                s->match_length = MIN_MATCH-1;
 1975|      0|            }
 1976|   169M|        }
 1977|       |        /* If there was a match at the previous step and the current
 1978|       |         * match is not better, output the previous match:
 1979|       |         */
 1980|   445M|        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
                                                         ^112M
  ------------------
  |  Branch (1980:13): [True: 112M, False: 333M]
  |  Branch (1980:44): [True: 99.9M, False: 12.0M]
  ------------------
 1981|  99.9M|            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
 1982|       |            /* Do not insert strings in hash table beyond this. */
 1983|       |
 1984|  99.9M|            check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
 1985|       |
 1986|  99.9M|            _tr_tally_dist(s, s->strstart - 1 - s->prev_match,
 1987|  99.9M|                           s->prev_length - MIN_MATCH, bflush);
 1988|       |
 1989|       |            /* Insert in hash table all strings up to the end of the match.
 1990|       |             * strstart - 1 and strstart are already inserted. If there is not
 1991|       |             * enough lookahead, the last two strings are not inserted in
 1992|       |             * the hash table.
 1993|       |             */
 1994|  99.9M|            s->lookahead -= s->prev_length - 1;
 1995|  99.9M|            s->prev_length -= 2;
 1996|  2.35G|            do {
 1997|  2.35G|                if (++s->strstart <= max_insert) {
  ------------------
  |  Branch (1997:21): [True: 2.32G, False: 30.1M]
  ------------------
 1998|  2.32G|                    INSERT_STRING(s, s->strstart, hash_head);
 1999|  2.32G|                }
 2000|  2.35G|            } while (--s->prev_length != 0);
  ------------------
  |  Branch (2000:22): [True: 2.25G, False: 99.9M]
  ------------------
 2001|  99.9M|            s->match_available = 0;
 2002|  99.9M|            s->match_length = MIN_MATCH-1;
 2003|  99.9M|            s->strstart++;
 2004|       |
 2005|  99.9M|            if (bflush) FLUSH_BLOCK(s, 0);
                                      ^0
  ------------------
  |  Branch (2005:17): [True: 0, False: 99.9M]
  ------------------
 2006|       |
 2007|   345M|        } else if (s->match_available) {
  ------------------
  |  Branch (2007:20): [True: 232M, False: 113M]
  ------------------
 2008|       |            /* If there was no match at the previous position, output a
 2009|       |             * single literal. If there was a match but the current match
 2010|       |             * is longer, truncate the previous match to a single literal.
 2011|       |             */
 2012|   232M|            Tracevv((stderr,"%c", s->window[s->strstart - 1]));
 2013|   232M|            _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
 2014|   232M|            if (bflush) {
  ------------------
  |  Branch (2014:17): [True: 0, False: 232M]
  ------------------
 2015|      0|                FLUSH_BLOCK_ONLY(s, 0);
 2016|      0|            }
 2017|   232M|            s->strstart++;
 2018|   232M|            s->lookahead--;
 2019|   232M|            if (s->strm->avail_out == 0) return need_more;
                                                       ^0
  ------------------
  |  Branch (2019:17): [True: 0, False: 232M]
  ------------------
 2020|   232M|        } else {
 2021|       |            /* There is no previous match to compare with, wait for
 2022|       |             * the next step to decide.
 2023|       |             */
 2024|   113M|            s->match_available = 1;
 2025|   113M|            s->strstart++;
 2026|   113M|            s->lookahead--;
 2027|   113M|        }
 2028|   445M|    }
 2029|  28.2M|    Assert (flush != Z_NO_FLUSH, "no flush?");
 2030|  28.2M|    if (s->match_available) {
  ------------------
  |  Branch (2030:9): [True: 13.1M, False: 15.1M]
  ------------------
 2031|  13.1M|        Tracevv((stderr,"%c", s->window[s->strstart - 1]));
 2032|  13.1M|        _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
 2033|  13.1M|        s->match_available = 0;
 2034|  13.1M|    }
 2035|  28.2M|    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
                                                          ^1.13M        ^27.1M   ^27.1M
  ------------------
  |  Branch (2035:17): [True: 1.13M, False: 27.1M]
  ------------------
 2036|  28.2M|    if (flush == Z_FINISH) {
  ------------------
  |  Branch (2036:9): [True: 15.2M, False: 13.0M]
  ------------------
 2037|  15.2M|        FLUSH_BLOCK(s, 1);
 2038|  15.2M|        return finish_done;
 2039|  15.2M|    }
 2040|  13.0M|    if (s->sym_next)
  ------------------
  |  Branch (2040:9): [True: 13.0M, False: 0]
  ------------------
 2041|  13.0M|        FLUSH_BLOCK(s, 0);
 2042|  13.0M|    return block_done;
 2043|  13.0M|}
 2044|       |#endif /* FASTEST */
 2045|       |
 2046|       |/* ===========================================================================
 2047|       | * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 2048|       | * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 2049|       | * deflate switches away from Z_RLE.)
 2050|       | */
 2051|      0|local block_state deflate_rle(deflate_state *s, int flush) {
 2052|      0|    int bflush;             /* set if current block must be flushed */
 2053|      0|    uInt prev;              /* byte at distance one to match */
 2054|      0|    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
 2055|       |
 2056|      0|    for (;;) {
 2057|       |        /* Make sure that we always have enough lookahead, except
 2058|       |         * at the end of the input file. We need MAX_MATCH bytes
 2059|       |         * for the longest run, plus one for the unrolled loop.
 2060|       |         */
 2061|      0|        if (s->lookahead <= MAX_MATCH) {
  ------------------
  |  Branch (2061:13): [True: 0, False: 0]
  ------------------
 2062|      0|            fill_window(s);
 2063|      0|            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
  ------------------
  |  Branch (2063:17): [True: 0, False: 0]
  |  Branch (2063:46): [True: 0, False: 0]
  ------------------
 2064|      0|                return need_more;
 2065|      0|            }
 2066|      0|            if (s->lookahead == 0) break; /* flush the current block */
  ------------------
  |  Branch (2066:17): [True: 0, False: 0]
  ------------------
 2067|      0|        }
 2068|       |
 2069|       |        /* See how many times the previous byte repeats */
 2070|      0|        s->match_length = 0;
 2071|      0|        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
  ------------------
  |  Branch (2071:13): [True: 0, False: 0]
  |  Branch (2071:42): [True: 0, False: 0]
  ------------------
 2072|      0|            scan = s->window + s->strstart - 1;
 2073|      0|            prev = *scan;
 2074|      0|            if (prev == *++scan && prev == *++scan && prev == *++scan) {
  ------------------
  |  Branch (2074:17): [True: 0, False: 0]
  |  Branch (2074:36): [True: 0, False: 0]
  |  Branch (2074:55): [True: 0, False: 0]
  ------------------
 2075|      0|                strend = s->window + s->strstart + MAX_MATCH;
 2076|      0|                do {
 2077|      0|                } while (prev == *++scan && prev == *++scan &&
  ------------------
  |  Branch (2077:26): [True: 0, False: 0]
  |  Branch (2077:45): [True: 0, False: 0]
  ------------------
 2078|      0|                         prev == *++scan && prev == *++scan &&
  ------------------
  |  Branch (2078:26): [True: 0, False: 0]
  |  Branch (2078:45): [True: 0, False: 0]
  ------------------
 2079|      0|                         prev == *++scan && prev == *++scan &&
  ------------------
  |  Branch (2079:26): [True: 0, False: 0]
  |  Branch (2079:45): [True: 0, False: 0]
  ------------------
 2080|      0|                         prev == *++scan && prev == *++scan &&
  ------------------
  |  Branch (2080:26): [True: 0, False: 0]
  |  Branch (2080:45): [True: 0, False: 0]
  ------------------
 2081|      0|                         scan < strend);
  ------------------
  |  Branch (2081:26): [True: 0, False: 0]
  ------------------
 2082|      0|                s->match_length = MAX_MATCH - (uInt)(strend - scan);
 2083|      0|                if (s->match_length > s->lookahead)
  ------------------
  |  Branch (2083:21): [True: 0, False: 0]
  ------------------
 2084|      0|                    s->match_length = s->lookahead;
 2085|      0|            }
 2086|      0|            Assert(scan <= s->window + (uInt)(s->window_size - 1),
 2087|      0|                   "wild scan");
 2088|      0|        }
 2089|       |
 2090|       |        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
 2091|      0|        if (s->match_length >= MIN_MATCH) {
  ------------------
  |  Branch (2091:13): [True: 0, False: 0]
  ------------------
 2092|      0|            check_match(s, s->strstart, s->strstart - 1, s->match_length);
 2093|       |
 2094|      0|            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
 2095|       |
 2096|      0|            s->lookahead -= s->match_length;
 2097|      0|            s->strstart += s->match_length;
 2098|      0|            s->match_length = 0;
 2099|      0|        } else {
 2100|       |            /* No match, output a literal byte */
 2101|      0|            Tracevv((stderr,"%c", s->window[s->strstart]));
 2102|      0|            _tr_tally_lit(s, s->window[s->strstart], bflush);
 2103|      0|            s->lookahead--;
 2104|      0|            s->strstart++;
 2105|      0|        }
 2106|      0|        if (bflush) FLUSH_BLOCK(s, 0);
  ------------------
  |  Branch (2106:13): [True: 0, False: 0]
  ------------------
 2107|      0|    }
 2108|      0|    s->insert = 0;
 2109|      0|    if (flush == Z_FINISH) {
  ------------------
  |  Branch (2109:9): [True: 0, False: 0]
  ------------------
 2110|      0|        FLUSH_BLOCK(s, 1);
 2111|      0|        return finish_done;
 2112|      0|    }
 2113|      0|    if (s->sym_next)
  ------------------
  |  Branch (2113:9): [True: 0, False: 0]
  ------------------
 2114|      0|        FLUSH_BLOCK(s, 0);
 2115|      0|    return block_done;
 2116|      0|}
 2117|       |
 2118|       |/* ===========================================================================
 2119|       | * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 2120|       | * (It will be regenerated if this run of deflate switches away from Huffman.)
 2121|       | */
 2122|      0|local block_state deflate_huff(deflate_state *s, int flush) {
 2123|      0|    int bflush;             /* set if current block must be flushed */
 2124|       |
 2125|      0|    for (;;) {
 2126|       |        /* Make sure that we have a literal to write. */
 2127|      0|        if (s->lookahead == 0) {
  ------------------
  |  Branch (2127:13): [True: 0, False: 0]
  ------------------
 2128|      0|            fill_window(s);
 2129|      0|            if (s->lookahead == 0) {
  ------------------
  |  Branch (2129:17): [True: 0, False: 0]
  ------------------
 2130|      0|                if (flush == Z_NO_FLUSH)
  ------------------
  |  Branch (2130:21): [True: 0, False: 0]
  ------------------
 2131|      0|                    return need_more;
 2132|      0|                break;      /* flush the current block */
 2133|      0|            }
 2134|      0|        }
 2135|       |
 2136|       |        /* Output a literal byte */
 2137|      0|        s->match_length = 0;
 2138|      0|        Tracevv((stderr,"%c", s->window[s->strstart]));
 2139|      0|        _tr_tally_lit(s, s->window[s->strstart], bflush);
 2140|      0|        s->lookahead--;
 2141|      0|        s->strstart++;
 2142|      0|        if (bflush) FLUSH_BLOCK(s, 0);
  ------------------
  |  Branch (2142:13): [True: 0, False: 0]
  ------------------
 2143|      0|    }
 2144|      0|    s->insert = 0;
 2145|      0|    if (flush == Z_FINISH) {
  ------------------
  |  Branch (2145:9): [True: 0, False: 0]
  ------------------
 2146|      0|        FLUSH_BLOCK(s, 1);
 2147|      0|        return finish_done;
 2148|      0|    }
 2149|      0|    if (s->sym_next)
  ------------------
  |  Branch (2149:9): [True: 0, False: 0]
  ------------------
 2150|      0|        FLUSH_BLOCK(s, 0);
 2151|      0|    return block_done;
 2152|      0|}

/home/minseo/alfha/targets/zlib/target/trees.c:
    1|       |/* trees.c -- output deflated data using Huffman coding
    2|       | * Copyright (C) 1995-2024 Jean-loup Gailly
    3|       | * detect_data_type() function provided freely by Cosmin Truta, 2006
    4|       | * For conditions of distribution and use, see copyright notice in zlib.h
    5|       | */
    6|       |
    7|       |/*
    8|       | *  ALGORITHM
    9|       | *
   10|       | *      The "deflation" process uses several Huffman trees. The more
   11|       | *      common source values are represented by shorter bit sequences.
   12|       | *
   13|       | *      Each code tree is stored in a compressed form which is itself
   14|       | * a Huffman encoding of the lengths of all the code strings (in
   15|       | * ascending order by source values).  The actual code strings are
   16|       | * reconstructed from the lengths in the inflate process, as described
   17|       | * in the deflate specification.
   18|       | *
   19|       | *  REFERENCES
   20|       | *
   21|       | *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
   22|       | *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
   23|       | *
   24|       | *      Storer, James A.
   25|       | *          Data Compression:  Methods and Theory, pp. 49-50.
   26|       | *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
   27|       | *
   28|       | *      Sedgewick, R.
   29|       | *          Algorithms, p290.
   30|       | *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
   31|       | */
   32|       |
   33|       |/* @(#) $Id$ */
   34|       |
   35|       |/* #define GEN_TREES_H */
   36|       |
   37|       |#include "deflate.h"
   38|       |
   39|       |#ifdef ZLIB_DEBUG
   40|       |#  include <ctype.h>
   41|       |#endif
   42|       |
   43|       |/* ===========================================================================
   44|       | * Constants
   45|       | */
   46|       |
   47|       |#define MAX_BL_BITS 7
   48|       |/* Bit length codes must not exceed MAX_BL_BITS bits */
   49|       |
   50|  94.8M|#define END_BLOCK 256
   51|       |/* end of block literal code */
   52|       |
   53|   918k|#define REP_3_6      16
   54|       |/* repeat previous bit length 3-6 times (2 bits of repeat count) */
   55|       |
   56|  66.2M|#define REPZ_3_10    17
   57|       |/* repeat a zero length 3-10 times  (3 bits of repeat count) */
   58|       |
   59|   111M|#define REPZ_11_138  18
   60|       |/* repeat a zero length 11-138 times  (7 bits of repeat count) */
   61|       |
   62|       |local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   63|       |   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
   64|       |
   65|       |local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   66|       |   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
   67|       |
   68|       |local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   69|       |   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
   70|       |
   71|       |local const uch bl_order[BL_CODES]
   72|       |   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
   73|       |/* The lengths of the bit length codes are sent in order of decreasing
   74|       | * probability, to avoid transmitting the lengths for unused bit length codes.
   75|       | */
   76|       |
   77|       |/* ===========================================================================
   78|       | * Local data. These are initialized only once.
   79|       | */
   80|       |
   81|       |#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
   82|       |
   83|       |#if defined(GEN_TREES_H) || !defined(STDC)
   84|       |/* non ANSI compilers may not accept trees.h */
   85|       |
   86|       |local ct_data static_ltree[L_CODES+2];
   87|       |/* The static literal tree. Since the bit lengths are imposed, there is no
   88|       | * need for the L_CODES extra codes used during heap construction. However
   89|       | * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
   90|       | * below).
   91|       | */
   92|       |
   93|       |local ct_data static_dtree[D_CODES];
   94|       |/* The static distance tree. (Actually a trivial tree since all codes use
   95|       | * 5 bits.)
   96|       | */
   97|       |
   98|       |uch _dist_code[DIST_CODE_LEN];
   99|       |/* Distance codes. The first 256 values correspond to the distances
  100|       | * 3 .. 258, the last 256 values correspond to the top 8 bits of
  101|       | * the 15 bit distances.
  102|       | */
  103|       |
  104|       |uch _length_code[MAX_MATCH-MIN_MATCH+1];
  105|       |/* length code for each normalized match length (0 == MIN_MATCH) */
  106|       |
  107|       |local int base_length[LENGTH_CODES];
  108|       |/* First normalized length for each code (0 = MIN_MATCH) */
  109|       |
  110|       |local int base_dist[D_CODES];
  111|       |/* First normalized distance for each code (0 = distance of 1) */
  112|       |
  113|       |#else
  114|       |#  include "trees.h"
  115|       |#endif /* GEN_TREES_H */
  116|       |
  117|       |struct static_tree_desc_s {
  118|       |    const ct_data *static_tree;  /* static tree or NULL */
  119|       |    const intf *extra_bits;      /* extra bits for each code or NULL */
  120|       |    int     extra_base;          /* base index for extra_bits */
  121|       |    int     elems;               /* max number of elements in the tree */
  122|       |    int     max_length;          /* max bit length for the codes */
  123|       |};
  124|       |
  125|       |#ifdef NO_INIT_GLOBAL_POINTERS
  126|       |#  define TCONST
  127|       |#else
  128|       |#  define TCONST const
  129|       |#endif
  130|       |
  131|       |local TCONST static_tree_desc static_l_desc =
  132|       |{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
  133|       |
  134|       |local TCONST static_tree_desc static_d_desc =
  135|       |{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
  136|       |
  137|       |local TCONST static_tree_desc static_bl_desc =
  138|       |{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
  139|       |
  140|       |/* ===========================================================================
  141|       | * Output a short LSB first on the stream.
  142|       | * IN assertion: there is enough room in pendingBuf.
  143|       | */
  144|   254M|#define put_short(s, w) { \
  145|   254M|    put_byte(s, (uch)((w) & 0xff)); \
  146|   254M|    put_byte(s, (uch)((ush)(w) >> 8)); \
  147|   254M|}
  148|       |
  149|       |/* ===========================================================================
  150|       | * Reverse the first len bits of a code, using straightforward code (a faster
  151|       | * method would use a table)
  152|       | * IN assertion: 1 <= len <= 15
  153|       | */
  154|   447M|local unsigned bi_reverse(unsigned code, int len) {
  155|   447M|    register unsigned res = 0;
  156|  1.40G|    do {
  157|  1.40G|        res |= code & 1;
  158|  1.40G|        code >>= 1, res <<= 1;
  159|  1.40G|    } while (--len > 0);
  ------------------
  |  Branch (159:14): [True: 952M, False: 447M]
  ------------------
  160|   447M|    return res >> 1;
  161|   447M|}
  162|       |
  163|       |/* ===========================================================================
  164|       | * Flush the bit buffer, keeping at most 7 bits in it.
  165|       | */
  166|  76.8M|local void bi_flush(deflate_state *s) {
  167|  76.8M|    if (s->bi_valid == 16) {
  ------------------
  |  Branch (167:9): [True: 1.13M, False: 75.7M]
  ------------------
  168|  1.13M|        put_short(s, s->bi_buf);
  169|  1.13M|        s->bi_buf = 0;
  170|  1.13M|        s->bi_valid = 0;
  171|  75.7M|    } else if (s->bi_valid >= 8) {
  ------------------
  |  Branch (171:16): [True: 10.1M, False: 65.5M]
  ------------------
  172|  10.1M|        put_byte(s, (Byte)s->bi_buf);
  173|  10.1M|        s->bi_buf >>= 8;
  174|  10.1M|        s->bi_valid -= 8;
  175|  10.1M|    }
  176|  76.8M|}
  177|       |
  178|       |/* ===========================================================================
  179|       | * Flush the bit buffer and align the output on a byte boundary
  180|       | */
  181|  23.9M|local void bi_windup(deflate_state *s) {
  182|  23.9M|    if (s->bi_valid > 8) {
  ------------------
  |  Branch (182:9): [True: 9.78M, False: 14.1M]
  ------------------
  183|  9.78M|        put_short(s, s->bi_buf);
  184|  14.1M|    } else if (s->bi_valid > 0) {
  ------------------
  |  Branch (184:16): [True: 14.1M, False: 18]
  ------------------
  185|  14.1M|        put_byte(s, (Byte)s->bi_buf);
  186|  14.1M|    }
  187|  23.9M|    s->bi_used = ((s->bi_valid - 1) & 7) + 1;
  188|  23.9M|    s->bi_buf = 0;
  189|  23.9M|    s->bi_valid = 0;
  190|       |#ifdef ZLIB_DEBUG
  191|       |    s->bits_sent = (s->bits_sent + 7) & ~7;
  192|       |#endif
  193|  23.9M|}
  194|       |
  195|       |/* ===========================================================================
  196|       | * Generate the codes for a given tree and bit counts (which need not be
  197|       | * optimal).
  198|       | * IN assertion: the array bl_count contains the bit length statistics for
  199|       | * the given tree and the field len is set for all tree elements.
  200|       | * OUT assertion: the field code is set for all tree elements of non
  201|       | *     zero code length.
  202|       | */
  203|  84.8M|local void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {
  204|  84.8M|    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
  205|  84.8M|    unsigned code = 0;         /* running code value */
  206|  84.8M|    int bits;                  /* bit index */
  207|  84.8M|    int n;                     /* code index */
  208|       |
  209|       |    /* The distribution counts are first used to generate the code values
  210|       |     * without bit reversal.
  211|       |     */
  212|  1.35G|    for (bits = 1; bits <= MAX_BITS; bits++) {
                                                   ^1.27G
  ------------------
  |  Branch (212:20): [True: 1.27G, False: 84.8M]
  ------------------
  213|  1.27G|        code = (code + bl_count[bits - 1]) << 1;
  214|  1.27G|        next_code[bits] = (ush)code;
  215|  1.27G|    }
  216|       |    /* Check that the bit counts in bl_count are consistent. The last code
  217|       |     * must be all ones.
  218|       |     */
  219|  84.8M|    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
  220|  84.8M|            "inconsistent bit counts");
  221|  84.8M|    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
  222|       |
  223|  8.42G|    for (n = 0;  n <= max_code; n++) {
                                              ^8.33G
  ------------------
  |  Branch (223:18): [True: 8.33G, False: 84.8M]
  ------------------
  224|  8.33G|        int len = tree[n].Len;
  225|  8.33G|        if (len == 0) continue;
                                    ^7.89G
  ------------------
  |  Branch (225:13): [True: 7.89G, False: 447M]
  ------------------
  226|       |        /* Now reverse the bits */
  227|   447M|        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
  228|       |
  229|   447M|        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
  230|   447M|            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
  231|   447M|    }
  232|  84.8M|}
  233|       |
  234|       |#ifdef GEN_TREES_H
  235|       |local void gen_trees_header(void);
  236|       |#endif
  237|       |
  238|       |#ifndef ZLIB_DEBUG
  239|   479M|#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
  240|       |   /* Send a code of the given tree. c and tree must not have side effects */
  241|       |
  242|       |#else /* !ZLIB_DEBUG */
  243|       |#  define send_code(s, c, tree) \
  244|       |     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
  245|       |       send_bits(s, tree[c].Code, tree[c].Len); }
  246|       |#endif
  247|       |
  248|       |/* ===========================================================================
  249|       | * Send a value on a given number of bits.
  250|       | * IN assertion: length <= 16 and value fits in length bits.
  251|       | */
  252|       |#ifdef ZLIB_DEBUG
  253|       |local void send_bits(deflate_state *s, int value, int length) {
  254|       |    Tracevv((stderr," l %2d v %4x ", length, value));
  255|       |    Assert(length > 0 && length <= 15, "invalid length");
  256|       |    s->bits_sent += (ulg)length;
  257|       |
  258|       |    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
  259|       |     * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))
  260|       |     * unused bits in value.
  261|       |     */
  262|       |    if (s->bi_valid > (int)Buf_size - length) {
  263|       |        s->bi_buf |= (ush)value << s->bi_valid;
  264|       |        put_short(s, s->bi_buf);
  265|       |        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
  266|       |        s->bi_valid += length - Buf_size;
  267|       |    } else {
  268|       |        s->bi_buf |= (ush)value << s->bi_valid;
  269|       |        s->bi_valid += length;
  270|       |    }
  271|       |}
  272|       |#else /* !ZLIB_DEBUG */
  273|       |
  274|   619M|#define send_bits(s, value, length) \
  275|   619M|{ int len = length;\
  276|   619M|  if (s->bi_valid > (int)Buf_size - len) {\
  277|   226M|    int val = (int)value;\
  278|   226M|    s->bi_buf |= (ush)val << s->bi_valid;\
  279|   226M|    put_short(s, s->bi_buf);\
  280|   226M|    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
  281|   226M|    s->bi_valid += len - Buf_size;\
  282|   392M|  } else {\
  283|   392M|    s->bi_buf |= (ush)(value) << s->bi_valid;\
  284|   392M|    s->bi_valid += len;\
  285|   392M|  }\
  286|   619M|}
  287|       |#endif /* ZLIB_DEBUG */
  288|       |
  289|       |
  290|       |/* the arguments must not have side effects */
  291|       |
  292|       |/* ===========================================================================
  293|       | * Initialize the various 'constant' tables.
  294|       | */
  295|  66.6M|local void tr_static_init(void) {
  296|       |#if defined(GEN_TREES_H) || !defined(STDC)
  297|       |    static int static_init_done = 0;
  298|       |    int n;        /* iterates over tree elements */
  299|       |    int bits;     /* bit counter */
  300|       |    int length;   /* length value */
  301|       |    int code;     /* code value */
  302|       |    int dist;     /* distance index */
  303|       |    ush bl_count[MAX_BITS+1];
  304|       |    /* number of codes at each bit length for an optimal tree */
  305|       |
  306|       |    if (static_init_done) return;
  307|       |
  308|       |    /* For some embedded targets, global variables are not initialized: */
  309|       |#ifdef NO_INIT_GLOBAL_POINTERS
  310|       |    static_l_desc.static_tree = static_ltree;
  311|       |    static_l_desc.extra_bits = extra_lbits;
  312|       |    static_d_desc.static_tree = static_dtree;
  313|       |    static_d_desc.extra_bits = extra_dbits;
  314|       |    static_bl_desc.extra_bits = extra_blbits;
  315|       |#endif
  316|       |
  317|       |    /* Initialize the mapping length (0..255) -> length code (0..28) */
  318|       |    length = 0;
  319|       |    for (code = 0; code < LENGTH_CODES-1; code++) {
  320|       |        base_length[code] = length;
  321|       |        for (n = 0; n < (1 << extra_lbits[code]); n++) {
  322|       |            _length_code[length++] = (uch)code;
  323|       |        }
  324|       |    }
  325|       |    Assert (length == 256, "tr_static_init: length != 256");
  326|       |    /* Note that the length 255 (match length 258) can be represented
  327|       |     * in two different ways: code 284 + 5 bits or code 285, so we
  328|       |     * overwrite length_code[255] to use the best encoding:
  329|       |     */
  330|       |    _length_code[length - 1] = (uch)code;
  331|       |
  332|       |    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  333|       |    dist = 0;
  334|       |    for (code = 0 ; code < 16; code++) {
  335|       |        base_dist[code] = dist;
  336|       |        for (n = 0; n < (1 << extra_dbits[code]); n++) {
  337|       |            _dist_code[dist++] = (uch)code;
  338|       |        }
  339|       |    }
  340|       |    Assert (dist == 256, "tr_static_init: dist != 256");
  341|       |    dist >>= 7; /* from now on, all distances are divided by 128 */
  342|       |    for ( ; code < D_CODES; code++) {
  343|       |        base_dist[code] = dist << 7;
  344|       |        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
  345|       |            _dist_code[256 + dist++] = (uch)code;
  346|       |        }
  347|       |    }
  348|       |    Assert (dist == 256, "tr_static_init: 256 + dist != 512");
  349|       |
  350|       |    /* Construct the codes of the static literal tree */
  351|       |    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
  352|       |    n = 0;
  353|       |    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
  354|       |    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
  355|       |    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
  356|       |    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
  357|       |    /* Codes 286 and 287 do not exist, but we must include them in the
  358|       |     * tree construction to get a canonical Huffman tree (longest code
  359|       |     * all ones)
  360|       |     */
  361|       |    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
  362|       |
  363|       |    /* The static distance tree is trivial: */
  364|       |    for (n = 0; n < D_CODES; n++) {
  365|       |        static_dtree[n].Len = 5;
  366|       |        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
  367|       |    }
  368|       |    static_init_done = 1;
  369|       |
  370|       |#  ifdef GEN_TREES_H
  371|       |    gen_trees_header();
  372|       |#  endif
  373|       |#endif /* defined(GEN_TREES_H) || !defined(STDC) */
  374|  66.6M|}
  375|       |
  376|       |/* ===========================================================================
  377|       | * Generate the file trees.h describing the static trees.
  378|       | */
  379|       |#ifdef GEN_TREES_H
  380|       |#  ifndef ZLIB_DEBUG
  381|       |#    include <stdio.h>
  382|       |#  endif
  383|       |
  384|       |#  define SEPARATOR(i, last, width) \
  385|       |      ((i) == (last)? "\n};\n\n" :    \
  386|       |       ((i) % (width) == (width) - 1 ? ",\n" : ", "))
  387|       |
  388|       |void gen_trees_header(void) {
  389|       |    FILE *header = fopen("trees.h", "w");
  390|       |    int i;
  391|       |
  392|       |    Assert (header != NULL, "Can't open trees.h");
  393|       |    fprintf(header,
  394|       |            "/* header created automatically with -DGEN_TREES_H */\n\n");
  395|       |
  396|       |    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
  397|       |    for (i = 0; i < L_CODES+2; i++) {
  398|       |        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
  399|       |                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
  400|       |    }
  401|       |
  402|       |    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
  403|       |    for (i = 0; i < D_CODES; i++) {
  404|       |        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
  405|       |                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
  406|       |    }
  407|       |
  408|       |    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
  409|       |    for (i = 0; i < DIST_CODE_LEN; i++) {
  410|       |        fprintf(header, "%2u%s", _dist_code[i],
  411|       |                SEPARATOR(i, DIST_CODE_LEN-1, 20));
  412|       |    }
  413|       |
  414|       |    fprintf(header,
  415|       |        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
  416|       |    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
  417|       |        fprintf(header, "%2u%s", _length_code[i],
  418|       |                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
  419|       |    }
  420|       |
  421|       |    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
  422|       |    for (i = 0; i < LENGTH_CODES; i++) {
  423|       |        fprintf(header, "%1u%s", base_length[i],
  424|       |                SEPARATOR(i, LENGTH_CODES-1, 20));
  425|       |    }
  426|       |
  427|       |    fprintf(header, "local const int base_dist[D_CODES] = {\n");
  428|       |    for (i = 0; i < D_CODES; i++) {
  429|       |        fprintf(header, "%5u%s", base_dist[i],
  430|       |                SEPARATOR(i, D_CODES-1, 10));
  431|       |    }
  432|       |
  433|       |    fclose(header);
  434|       |}
  435|       |#endif /* GEN_TREES_H */
  436|       |
  437|       |/* ===========================================================================
  438|       | * Initialize a new block.
  439|       | */
  440|  94.8M|local void init_block(deflate_state *s) {
  441|  94.8M|    int n; /* iterates over tree elements */
  442|       |
  443|       |    /* Initialize the trees. */
  444|  27.2G|    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
                                            ^27.1G^27.1G          ^27.1G
  ------------------
  |  Branch (444:17): [True: 27.1G, False: 94.8M]
  ------------------
  445|  2.94G|    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
                                            ^2.84G^2.84G          ^2.84G
  ------------------
  |  Branch (445:17): [True: 2.84G, False: 94.8M]
  ------------------
  446|  1.89G|    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
                                            ^1.80G^1.80G        ^1.80G
  ------------------
  |  Branch (446:17): [True: 1.80G, False: 94.8M]
  ------------------
  447|       |
  448|  94.8M|    s->dyn_ltree[END_BLOCK].Freq = 1;
  449|  94.8M|    s->opt_len = s->static_len = 0L;
  450|  94.8M|    s->sym_next = s->matches = 0;
  451|  94.8M|}
  452|       |
  453|       |/* ===========================================================================
  454|       | * Initialize the tree data structures for a new zlib stream.
  455|       | */
  456|  66.6M|void ZLIB_INTERNAL _tr_init(deflate_state *s) {
  457|  66.6M|    tr_static_init();
  458|       |
  459|  66.6M|    s->l_desc.dyn_tree = s->dyn_ltree;
  460|  66.6M|    s->l_desc.stat_desc = &static_l_desc;
  461|       |
  462|  66.6M|    s->d_desc.dyn_tree = s->dyn_dtree;
  463|  66.6M|    s->d_desc.stat_desc = &static_d_desc;
  464|       |
  465|  66.6M|    s->bl_desc.dyn_tree = s->bl_tree;
  466|  66.6M|    s->bl_desc.stat_desc = &static_bl_desc;
  467|       |
  468|  66.6M|    s->bi_buf = 0;
  469|  66.6M|    s->bi_valid = 0;
  470|  66.6M|    s->bi_used = 0;
  471|       |#ifdef ZLIB_DEBUG
  472|       |    s->compressed_len = 0L;
  473|       |    s->bits_sent = 0L;
  474|       |#endif
  475|       |
  476|       |    /* Initialize the first block of the first file: */
  477|  66.6M|    init_block(s);
  478|  66.6M|}
  479|       |
  480|  2.26G|#define SMALLEST 1
  481|       |/* Index within the heap array of least frequent node in the Huffman tree */
  482|       |
  483|       |
  484|       |/* ===========================================================================
  485|       | * Remove the smallest element from the heap and recreate the heap with
  486|       | * one less element. Updates heap and heap_len.
  487|       | */
  488|   362M|#define pqremove(s, tree, top) \
  489|   362M|{\
  490|   362M|    top = s->heap[SMALLEST]; \
  491|   362M|    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
  492|   362M|    pqdownheap(s, tree, SMALLEST); \
  493|   362M|}
  494|       |
  495|       |/* ===========================================================================
  496|       | * Compares to subtrees, using the tree depth as tie breaker when
  497|       | * the subtrees have equal frequency. This minimizes the worst case length.
  498|       | */
  499|       |#define smaller(tree, n, m, depth) \
  500|  2.38G|   (tree[n].Freq < tree[m].Freq || \
  501|  2.38G|   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
                 ^2.15G^2.15G  ^2.15G          ^2.15G  ^756M
  502|       |
  503|       |/* ===========================================================================
  504|       | * Restore the heap property by moving down the tree starting at node k,
  505|       | * exchanging a node with the smallest of its two sons if necessary, stopping
  506|       | * when the heap property is re-established (each father smaller than its
  507|       | * two sons).
  508|       | */
  509|   935M|local void pqdownheap(deflate_state *s, ct_data *tree, int k) {
  510|   935M|    int v = s->heap[k];
  511|   935M|    int j = k << 1;  /* left son of k */
  512|  1.96G|    while (j <= s->heap_len) {
  ------------------
  |  Branch (512:12): [True: 1.31G, False: 649M]
  ------------------
  513|       |        /* Set j to the smallest of the two sons: */
  514|  1.31G|        if (j < s->heap_len &&
  ------------------
  |  Branch (514:13): [True: 1.06G, False: 248M]
  ------------------
  515|  1.31G|            smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
                          ^1.06G
  516|   540M|            j++;
  517|   540M|        }
  518|       |        /* Exit if v is smaller than both sons */
  519|  1.31G|        if (smaller(tree, v, s->heap[j], s->depth)) break;
                                                                  ^285M
  520|       |
  521|       |        /* Exchange v with the smallest son */
  522|  1.02G|        s->heap[k] = s->heap[j];  k = j;
  523|       |
  524|       |        /* And continue down the tree, setting j to the left son of k */
  525|  1.02G|        j <<= 1;
  526|  1.02G|    }
  527|   935M|    s->heap[k] = v;
  528|   935M|}
  529|       |
  530|       |/* ===========================================================================
  531|       | * Compute the optimal bit lengths for a tree and update the total bit length
  532|       | * for the current block.
  533|       | * IN assertion: the fields freq and dad are set, heap[heap_max] and
  534|       | *    above are the tree nodes sorted by increasing frequency.
  535|       | * OUT assertions: the field len is set to the optimal bit length, the
  536|       | *     array bl_count contains the frequencies for each bit length.
  537|       | *     The length opt_len is updated; static_len is also updated if stree is
  538|       | *     not null.
  539|       | */
  540|  84.8M|local void gen_bitlen(deflate_state *s, tree_desc *desc) {
  541|  84.8M|    ct_data *tree        = desc->dyn_tree;
  542|  84.8M|    int max_code         = desc->max_code;
  543|  84.8M|    const ct_data *stree = desc->stat_desc->static_tree;
  544|  84.8M|    const intf *extra    = desc->stat_desc->extra_bits;
  545|  84.8M|    int base             = desc->stat_desc->extra_base;
  546|  84.8M|    int max_length       = desc->stat_desc->max_length;
  547|  84.8M|    int h;              /* heap index */
  548|  84.8M|    int n, m;           /* iterate over the tree elements */
  549|  84.8M|    int bits;           /* bit length */
  550|  84.8M|    int xbits;          /* extra bits */
  551|  84.8M|    ush f;              /* frequency */
  552|  84.8M|    int overflow = 0;   /* number of elements with bit length too large */
  553|       |
  554|  1.44G|    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
                                                   ^1.35G  ^1.35G
  ------------------
  |  Branch (554:20): [True: 1.35G, False: 84.8M]
  ------------------
  555|       |
  556|       |    /* In a first pass, compute the optimal bit lengths (which may
  557|       |     * overflow in the case of the bit length tree).
  558|       |     */
  559|  84.8M|    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
  560|       |
  561|   810M|    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
                                                           ^725M
  ------------------
  |  Branch (561:31): [True: 725M, False: 84.8M]
  ------------------
  562|   725M|        n = s->heap[h];
  563|   725M|        bits = tree[tree[n].Dad].Len + 1;
  564|   725M|        if (bits > max_length) bits = max_length, overflow++;
                                             ^0
  ------------------
  |  Branch (564:13): [True: 0, False: 725M]
  ------------------
  565|   725M|        tree[n].Len = (ush)bits;
  566|       |        /* We overwrite tree[n].Dad which is no longer needed */
  567|       |
  568|   725M|        if (n > max_code) continue; /* not a leaf node */
                                        ^278M
  ------------------
  |  Branch (568:13): [True: 278M, False: 447M]
  ------------------
  569|       |
  570|   447M|        s->bl_count[bits]++;
  571|   447M|        xbits = 0;
  572|   447M|        if (n >= base) xbits = extra[n - base];
                                     ^287M
  ------------------
  |  Branch (572:13): [True: 287M, False: 160M]
  ------------------
  573|   447M|        f = tree[n].Freq;
  574|   447M|        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
  575|   447M|        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
                                 ^313M                                         ^313M
  ------------------
  |  Branch (575:13): [True: 313M, False: 134M]
  ------------------
  576|   447M|    }
  577|  84.8M|    if (overflow == 0) return;
  ------------------
  |  Branch (577:9): [True: 84.8M, False: 0]
  ------------------
  578|       |
  579|      0|    Tracev((stderr,"\nbit length overflow\n"));
  580|       |    /* This happens for example on obj2 and pic of the Calgary corpus */
  581|       |
  582|       |    /* Find the first bit length which could increase: */
  583|      0|    do {
  584|      0|        bits = max_length - 1;
  585|      0|        while (s->bl_count[bits] == 0) bits--;
  ------------------
  |  Branch (585:16): [True: 0, False: 0]
  ------------------
  586|      0|        s->bl_count[bits]--;        /* move one leaf down the tree */
  587|      0|        s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
  588|      0|        s->bl_count[max_length]--;
  589|       |        /* The brother of the overflow item also moves one step up,
  590|       |         * but this does not affect bl_count[max_length]
  591|       |         */
  592|      0|        overflow -= 2;
  593|      0|    } while (overflow > 0);
  ------------------
  |  Branch (593:14): [True: 0, False: 0]
  ------------------
  594|       |
  595|       |    /* Now recompute all bit lengths, scanning in increasing frequency.
  596|       |     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
  597|       |     * lengths instead of fixing only the wrong ones. This idea is taken
  598|       |     * from 'ar' written by Haruhiko Okumura.)
  599|       |     */
  600|      0|    for (bits = max_length; bits != 0; bits--) {
  ------------------
  |  Branch (600:29): [True: 0, False: 0]
  ------------------
  601|      0|        n = s->bl_count[bits];
  602|      0|        while (n != 0) {
  ------------------
  |  Branch (602:16): [True: 0, False: 0]
  ------------------
  603|      0|            m = s->heap[--h];
  604|      0|            if (m > max_code) continue;
  ------------------
  |  Branch (604:17): [True: 0, False: 0]
  ------------------
  605|      0|            if ((unsigned) tree[m].Len != (unsigned) bits) {
  ------------------
  |  Branch (605:17): [True: 0, False: 0]
  ------------------
  606|      0|                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
  607|      0|                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
  608|      0|                tree[m].Len = (ush)bits;
  609|      0|            }
  610|      0|            n--;
  611|      0|        }
  612|      0|    }
  613|      0|}
  614|       |
  615|       |#ifdef DUMP_BL_TREE
  616|       |#  include <stdio.h>
  617|       |#endif
  618|       |
  619|       |/* ===========================================================================
  620|       | * Construct one Huffman tree and assigns the code bit strings and lengths.
  621|       | * Update the total bit length for the current block.
  622|       | * IN assertion: the field freq is set for all tree elements.
  623|       | * OUT assertions: the fields len and code are set to the optimal bit length
  624|       | *     and corresponding code. The length opt_len is updated; static_len is
  625|       | *     also updated if stree is not null. The field max_code is set.
  626|       | */
  627|  84.8M|local void build_tree(deflate_state *s, tree_desc *desc) {
  628|  84.8M|    ct_data *tree         = desc->dyn_tree;
  629|  84.8M|    const ct_data *stree  = desc->stat_desc->static_tree;
  630|  84.8M|    int elems             = desc->stat_desc->elems;
  631|  84.8M|    int n, m;          /* iterate over heap elements */
  632|  84.8M|    int max_code = -1; /* largest code with non zero frequency */
  633|  84.8M|    int node;          /* new node being created */
  634|       |
  635|       |    /* Construct the initial heap, with least frequent element in
  636|       |     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
  637|       |     * heap[0] is not used.
  638|       |     */
  639|  84.8M|    s->heap_len = 0, s->heap_max = HEAP_SIZE;
  640|       |
  641|  9.55G|    for (n = 0; n < elems; n++) {
                                         ^9.47G
  ------------------
  |  Branch (641:17): [True: 9.47G, False: 84.8M]
  ------------------
  642|  9.47G|        if (tree[n].Freq != 0) {
  ------------------
  |  Branch (642:13): [True: 422M, False: 9.05G]
  ------------------
  643|   422M|            s->heap[++(s->heap_len)] = max_code = n;
  644|   422M|            s->depth[n] = 0;
  645|  9.05G|        } else {
  646|  9.05G|            tree[n].Len = 0;
  647|  9.05G|        }
  648|  9.47G|    }
  649|       |
  650|       |    /* The pkzip format requires that at least one distance code exists,
  651|       |     * and that at least one bit should be sent even if there is only one
  652|       |     * possible code. So to avoid special checks later on we force at least
  653|       |     * two codes of non zero frequency.
  654|       |     */
  655|   110M|    while (s->heap_len < 2) {
  ------------------
  |  Branch (655:12): [True: 25.6M, False: 84.8M]
  ------------------
  656|  25.6M|        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
                                                                        ^18.2M       ^7.43M
  ------------------
  |  Branch (656:44): [True: 18.2M, False: 7.43M]
  ------------------
  657|  25.6M|        tree[node].Freq = 1;
  658|  25.6M|        s->depth[node] = 0;
  659|  25.6M|        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
  ------------------
  |  Branch (659:27): [True: 25.6M, False: 0]
  ------------------
  660|       |        /* node is 0 or 1 so it does not have extra bits */
  661|  25.6M|    }
  662|  84.8M|    desc->max_code = max_code;
  663|       |
  664|       |    /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
  665|       |     * establish sub-heaps of increasing lengths:
  666|       |     */
  667|   294M|    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
                                                  ^209M^209M
  ------------------
  |  Branch (667:29): [True: 209M, False: 84.8M]
  ------------------
  668|       |
  669|       |    /* Construct the Huffman tree by repeatedly combining the least two
  670|       |     * frequent nodes.
  671|       |     */
  672|  84.8M|    node = elems;              /* next internal node of the tree */
  673|   362M|    do {
  674|   362M|        pqremove(s, tree, n);  /* n = node of least frequency */
  675|   362M|        m = s->heap[SMALLEST]; /* m = node of next least frequency */
  676|       |
  677|   362M|        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
  678|   362M|        s->heap[--(s->heap_max)] = m;
  679|       |
  680|       |        /* Create a new node father of n and m */
  681|   362M|        tree[node].Freq = tree[n].Freq + tree[m].Freq;
  682|   362M|        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
  ------------------
  |  Branch (682:33): [True: 281M, False: 81.3M]
  ------------------
  683|   281M|                                s->depth[n] : s->depth[m]) + 1);
                                                            ^81.3M
  684|   362M|        tree[n].Dad = tree[m].Dad = (ush)node;
  685|       |#ifdef DUMP_BL_TREE
  686|       |        if (tree == s->bl_tree) {
  687|       |            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
  688|       |                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
  689|       |        }
  690|       |#endif
  691|       |        /* and insert the new node in the heap */
  692|   362M|        s->heap[SMALLEST] = node++;
  693|   362M|        pqdownheap(s, tree, SMALLEST);
  694|       |
  695|   362M|    } while (s->heap_len >= 2);
  ------------------
  |  Branch (695:14): [True: 278M, False: 84.8M]
  ------------------
  696|       |
  697|  84.8M|    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
  698|       |
  699|       |    /* At this point, the fields freq and dad are set. We can now
  700|       |     * generate the bit lengths.
  701|       |     */
  702|  84.8M|    gen_bitlen(s, (tree_desc *)desc);
  703|       |
  704|       |    /* The field len is now set, we can generate the bit codes */
  705|  84.8M|    gen_codes ((ct_data *)tree, max_code, s->bl_count);
  706|  84.8M|}
  707|       |
  708|       |/* ===========================================================================
  709|       | * Scan a literal or distance tree to determine the frequencies of the codes
  710|       | * in the bit length tree.
  711|       | */
  712|  56.5M|local void scan_tree(deflate_state *s, ct_data *tree, int max_code) {
  713|  56.5M|    int n;                     /* iterates over all tree elements */
  714|  56.5M|    int prevlen = -1;          /* last emitted length */
  715|  56.5M|    int curlen;                /* length of current code */
  716|  56.5M|    int nextlen = tree[0].Len; /* length of next code */
  717|  56.5M|    int count = 0;             /* repeat count of the current code */
  718|  56.5M|    int max_count = 7;         /* max repeat count */
  719|  56.5M|    int min_count = 4;         /* min repeat count */
  720|       |
  721|  56.5M|    if (nextlen == 0) max_count = 138, min_count = 3;
                                    ^16.6M
  ------------------
  |  Branch (721:9): [True: 16.6M, False: 39.9M]
  ------------------
  722|  56.5M|    tree[max_code + 1].Len = (ush)0xffff; /* guard */
  723|       |
  724|  7.85G|    for (n = 0; n <= max_code; n++) {
                                             ^7.80G
  ------------------
  |  Branch (724:17): [True: 7.80G, False: 56.5M]
  ------------------
  725|  7.80G|        curlen = nextlen; nextlen = tree[n + 1].Len;
  726|  7.80G|        if (++count < max_count && curlen == nextlen) {
                                                 ^7.78G
  ------------------
  |  Branch (726:13): [True: 7.78G, False: 19.4M]
  |  Branch (726:36): [True: 7.30G, False: 482M]
  ------------------
  727|  7.30G|            continue;
  728|  7.30G|        } else if (count < min_count) {
                             ^501M^501M
  ------------------
  |  Branch (728:20): [True: 322M, False: 178M]
  ------------------
  729|   322M|            s->bl_tree[curlen].Freq += (ush)count;
  730|   322M|        } else if (curlen != 0) {
                             ^178M^178M
  ------------------
  |  Branch (730:20): [True: 918k, False: 177M]
  ------------------
  731|   918k|            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
                                                 ^918k              ^918k
  ------------------
  |  Branch (731:17): [True: 918k, False: 187]
  ------------------
  732|   918k|            s->bl_tree[REP_3_6].Freq++;
  733|   177M|        } else if (count <= 10) {
  ------------------
  |  Branch (733:20): [True: 66.2M, False: 111M]
  ------------------
  734|  66.2M|            s->bl_tree[REPZ_3_10].Freq++;
  735|   111M|        } else {
  736|   111M|            s->bl_tree[REPZ_11_138].Freq++;
  737|   111M|        }
  738|   501M|        count = 0; prevlen = curlen;
  739|   501M|        if (nextlen == 0) {
  ------------------
  |  Branch (739:13): [True: 208M, False: 293M]
  ------------------
  740|   208M|            max_count = 138, min_count = 3;
  741|   293M|        } else if (curlen == nextlen) {
  ------------------
  |  Branch (741:20): [True: 3.13k, False: 293M]
  ------------------
  742|  3.13k|            max_count = 6, min_count = 3;
  743|   293M|        } else {
  744|   293M|            max_count = 7, min_count = 4;
  745|   293M|        }
  746|   501M|    }
  747|  56.5M|}
  748|       |
  749|       |/* ===========================================================================
  750|       | * Send a literal or distance tree in compressed form, using the codes in
  751|       | * bl_tree.
  752|       | */
  753|  28.3k|local void send_tree(deflate_state *s, ct_data *tree, int max_code) {
  754|  28.3k|    int n;                     /* iterates over all tree elements */
  755|  28.3k|    int prevlen = -1;          /* last emitted length */
  756|  28.3k|    int curlen;                /* length of current code */
  757|  28.3k|    int nextlen = tree[0].Len; /* length of next code */
  758|  28.3k|    int count = 0;             /* repeat count of the current code */
  759|  28.3k|    int max_count = 7;         /* max repeat count */
  760|  28.3k|    int min_count = 4;         /* min repeat count */
  761|       |
  762|       |    /* tree[max_code + 1].Len = -1; */  /* guard already set */
  763|  28.3k|    if (nextlen == 0) max_count = 138, min_count = 3;
                                    ^10
  ------------------
  |  Branch (763:9): [True: 10, False: 28.3k]
  ------------------
  764|       |
  765|  4.07M|    for (n = 0; n <= max_code; n++) {
                                             ^4.04M
  ------------------
  |  Branch (765:17): [True: 4.04M, False: 28.3k]
  ------------------
  766|  4.04M|        curlen = nextlen; nextlen = tree[n + 1].Len;
  767|  4.04M|        if (++count < max_count && curlen == nextlen) {
                                                 ^4.04M
  ------------------
  |  Branch (767:13): [True: 4.04M, False: 306]
  |  Branch (767:36): [True: 3.28M, False: 761k]
  ------------------
  768|  3.28M|            continue;
  769|  3.28M|        } else if (count < min_count) {
                             ^761k^761k
  ------------------
  |  Branch (769:20): [True: 588k, False: 173k]
  ------------------
  770|   707k|            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
  ------------------
  |  Branch (770:61): [True: 119k, False: 588k]
  ------------------
  771|       |
  772|   588k|        } else if (curlen != 0) {
                             ^173k^173k
  ------------------
  |  Branch (772:20): [True: 4.51k, False: 169k]
  ------------------
  773|  4.51k|            if (curlen != prevlen) {
  ------------------
  |  Branch (773:17): [True: 4.51k, False: 2]
  ------------------
  774|  4.51k|                send_code(s, curlen, s->bl_tree); count--;
  775|  4.51k|            }
  776|  4.51k|            Assert(count >= 3 && count <= 6, " 3_6?");
  777|  4.51k|            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);
  778|       |
  779|   169k|        } else if (count <= 10) {
  ------------------
  |  Branch (779:20): [True: 73.4k, False: 95.7k]
  ------------------
  780|  73.4k|            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);
  781|       |
  782|  95.7k|        } else {
  783|  95.7k|            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);
  784|  95.7k|        }
  785|   761k|        count = 0; prevlen = curlen;
  786|   761k|        if (nextlen == 0) {
  ------------------
  |  Branch (786:13): [True: 292k, False: 468k]
  ------------------
  787|   292k|            max_count = 138, min_count = 3;
  788|   468k|        } else if (curlen == nextlen) {
  ------------------
  |  Branch (788:20): [True: 32, False: 468k]
  ------------------
  789|     32|            max_count = 6, min_count = 3;
  790|   468k|        } else {
  791|   468k|            max_count = 7, min_count = 4;
  792|   468k|        }
  793|   761k|    }
  794|  28.3k|}
  795|       |
  796|       |/* ===========================================================================
  797|       | * Construct the Huffman tree for the bit lengths and return the index in
  798|       | * bl_order of the last bit length code to send.
  799|       | */
  800|  28.2M|local int build_bl_tree(deflate_state *s) {
  801|  28.2M|    int max_blindex;  /* index of last bit length code of non zero freq */
  802|       |
  803|       |    /* Determine the bit length frequencies for literal and distance trees */
  804|  28.2M|    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
  805|  28.2M|    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
  806|       |
  807|       |    /* Build the bit length tree: */
  808|  28.2M|    build_tree(s, (tree_desc *)(&(s->bl_desc)));
  809|       |    /* opt_len now includes the length of the tree representations, except the
  810|       |     * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
  811|       |     */
  812|       |
  813|       |    /* Determine the number of bit length codes to send. The pkzip format
  814|       |     * requires that at least 4 bit length codes be sent. (appnote.txt says
  815|       |     * 3 but the actual value used is 4.)
  816|       |     */
  817|  59.8M|    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
                                     ^28.2M                        ^31.5M
  ------------------
  |  Branch (817:36): [True: 59.8M, False: 0]
  ------------------
  818|  59.8M|        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
                                                                      ^28.2M
  ------------------
  |  Branch (818:13): [True: 28.2M, False: 31.5M]
  ------------------
  819|  59.8M|    }
  820|       |    /* Update opt_len to include the bit length tree and counts */
  821|  28.2M|    s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;
  822|  28.2M|    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  823|  28.2M|            s->opt_len, s->static_len));
  824|       |
  825|  28.2M|    return max_blindex;
  826|  28.2M|}
  827|       |
  828|       |/* ===========================================================================
  829|       | * Send the header for a block using dynamic Huffman trees: the counts, the
  830|       | * lengths of the bit length codes, the literal tree and the distance tree.
  831|       | * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
  832|       | */
  833|       |local void send_all_trees(deflate_state *s, int lcodes, int dcodes,
  834|  14.1k|                          int blcodes) {
  835|  14.1k|    int rank;                    /* index in bl_order */
  836|       |
  837|  14.1k|    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  838|  14.1k|    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  839|  14.1k|            "too many codes");
  840|  14.1k|    Tracev((stderr, "\nbl counts: "));
  841|  14.1k|    send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */
  842|  14.1k|    send_bits(s, dcodes - 1,   5);
  843|  14.1k|    send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */
  844|   265k|    for (rank = 0; rank < blcodes; rank++) {
                                                 ^251k
  ------------------
  |  Branch (844:20): [True: 251k, False: 14.1k]
  ------------------
  845|   251k|        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
  846|   251k|        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
  847|   251k|    }
  848|  14.1k|    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
  849|       |
  850|  14.1k|    send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */
  851|  14.1k|    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
  852|       |
  853|  14.1k|    send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */
  854|  14.1k|    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
  855|  14.1k|}
  856|       |
  857|       |/* ===========================================================================
  858|       | * Send a stored block
  859|       | */
  860|       |void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,
  861|  8.66M|                                    ulg stored_len, int last) {
  862|  8.66M|    send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */
  863|  8.66M|    bi_windup(s);        /* align on byte boundary */
  864|  8.66M|    put_short(s, (ush)stored_len);
  865|  8.66M|    put_short(s, (ush)~stored_len);
  866|  8.66M|    if (stored_len)
  ------------------
  |  Branch (866:9): [True: 18, False: 8.66M]
  ------------------
  867|     18|        zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
  868|  8.66M|    s->pending += stored_len;
  869|       |#ifdef ZLIB_DEBUG
  870|       |    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
  871|       |    s->compressed_len += (stored_len + 4) << 3;
  872|       |    s->bits_sent += 2*16;
  873|       |    s->bits_sent += stored_len << 3;
  874|       |#endif
  875|  8.66M|}
  876|       |
  877|       |/* ===========================================================================
  878|       | * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
  879|       | */
  880|  72.5M|void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s) {
  881|  72.5M|    bi_flush(s);
  882|  72.5M|}
  883|       |
  884|       |/* ===========================================================================
  885|       | * Send one empty static block to give enough lookahead for inflate.
  886|       | * This takes 10 bits, of which 7 may remain in the bit buffer.
  887|       | */
  888|  4.34M|void ZLIB_INTERNAL _tr_align(deflate_state *s) {
  889|  4.34M|    send_bits(s, STATIC_TREES<<1, 3);
  890|  4.34M|    send_code(s, END_BLOCK, static_ltree);
  891|       |#ifdef ZLIB_DEBUG
  892|       |    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
  893|       |#endif
  894|  4.34M|    bi_flush(s);
  895|  4.34M|}
  896|       |
  897|       |/* ===========================================================================
  898|       | * Send the block data compressed using the given Huffman trees
  899|       | */
  900|       |local void compress_block(deflate_state *s, const ct_data *ltree,
  901|  28.2M|                          const ct_data *dtree) {
  902|  28.2M|    unsigned dist;      /* distance of matched string */
  903|  28.2M|    int lc;             /* match length or unmatched char (if dist == 0) */
  904|  28.2M|    unsigned sx = 0;    /* running index in symbol buffers */
  905|  28.2M|    unsigned code;      /* the code to send */
  906|  28.2M|    int extra;          /* number of extra bits to send */
  907|       |
  908|   345M|    if (s->sym_next != 0) do {
                      ^28.2M            ^28.2M
  ------------------
  |  Branch (908:9): [True: 28.2M, False: 0]
  ------------------
  909|       |#ifdef LIT_MEM
  910|       |        dist = s->d_buf[sx];
  911|       |        lc = s->l_buf[sx++];
  912|       |#else
  913|   345M|        dist = s->sym_buf[sx++] & 0xff;
  914|   345M|        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;
  915|   345M|        lc = s->sym_buf[sx++];
  916|   345M|#endif
  917|   345M|        if (dist == 0) {
  ------------------
  |  Branch (917:13): [True: 245M, False: 99.9M]
  ------------------
  918|   245M|            send_code(s, lc, ltree); /* send a literal byte */
  919|   245M|            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
  920|   245M|        } else {
  921|       |            /* Here, lc is the match length - MIN_MATCH */
  922|  99.9M|            code = _length_code[lc];
  923|  99.9M|            send_code(s, code + LITERALS + 1, ltree);   /* send length code */
  924|  99.9M|            extra = extra_lbits[code];
  925|  99.9M|            if (extra != 0) {
  ------------------
  |  Branch (925:17): [True: 48.3M, False: 51.6M]
  ------------------
  926|  48.3M|                lc -= base_length[code];
  927|  48.3M|                send_bits(s, lc, extra);       /* send the extra length bits */
  928|  48.3M|            }
  929|  99.9M|            dist--; /* dist is now the match distance - 1 */
  930|  99.9M|            code = d_code(dist);
  931|  99.9M|            Assert (code < D_CODES, "bad d_code");
  932|       |
  933|  99.9M|            send_code(s, code, dtree);       /* send the distance code */
  934|  99.9M|            extra = extra_dbits[code];
  935|  99.9M|            if (extra != 0) {
  ------------------
  |  Branch (935:17): [True: 50.1M, False: 49.7M]
  ------------------
  936|  50.1M|                dist -= (unsigned)base_dist[code];
  937|  50.1M|                send_bits(s, dist, extra);   /* send the extra distance bits */
  938|  50.1M|            }
  939|  99.9M|        } /* literal or match pair ? */
  940|       |
  941|       |        /* Check for no overlay of pending_buf on needed symbols */
  942|       |#ifdef LIT_MEM
  943|       |        Assert(s->pending < 2 * (s->lit_bufsize + sx), "pendingBuf overflow");
  944|       |#else
  945|   345M|        Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
  946|   345M|#endif
  947|       |
  948|   345M|    } while (sx < s->sym_next);
  ------------------
  |  Branch (948:14): [True: 317M, False: 28.2M]
  ------------------
  949|       |
  950|  28.2M|    send_code(s, END_BLOCK, ltree);
  951|  28.2M|}
  952|       |
  953|       |/* ===========================================================================
  954|       | * Check if the data type is TEXT or BINARY, using the following algorithm:
  955|       | * - TEXT if the two conditions below are satisfied:
  956|       | *    a) There are no non-portable control characters belonging to the
  957|       | *       "block list" (0..6, 14..25, 28..31).
  958|       | *    b) There is at least one printable character belonging to the
  959|       | *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
  960|       | * - BINARY otherwise.
  961|       | * - The following partially-portable control characters form a
  962|       | *   "gray list" that is ignored in this detection algorithm:
  963|       | *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
  964|       | * IN assertion: the fields Freq of dyn_ltree are set.
  965|       | */
  966|  15.3M|local int detect_data_type(deflate_state *s) {
  967|       |    /* block_mask is the bit mask of block-listed bytes
  968|       |     * set bits 0..6, 14..25, and 28..31
  969|       |     * 0xf3ffc07f = binary 11110011111111111100000001111111
  970|       |     */
  971|  15.3M|    unsigned long block_mask = 0xf3ffc07fUL;
  972|  15.3M|    int n;
  973|       |
  974|       |    /* Check for non-textual ("block-listed") bytes. */
  975|   181M|    for (n = 0; n <= 31; n++, block_mask >>= 1)
                                       ^166M
  ------------------
  |  Branch (975:17): [True: 176M, False: 4.97M]
  ------------------
  976|   176M|        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))
                                              ^129M            ^129M
  ------------------
  |  Branch (976:13): [True: 129M, False: 47.2M]
  |  Branch (976:33): [True: 10.3M, False: 118M]
  ------------------
  977|  10.3M|            return Z_BINARY;
  978|       |
  979|       |    /* Check for textual ("allow-listed") bytes. */
  980|  4.97M|    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
                                                   ^4.93M           ^4.93M
  ------------------
  |  Branch (980:9): [True: 39.0k, False: 4.93M]
  |  Branch (980:38): [True: 1.35M, False: 3.58M]
  ------------------
  981|  4.97M|            || s->dyn_ltree[13].Freq != 0)
                             ^3.58M           ^3.58M
  ------------------
  |  Branch (981:16): [True: 10.8k, False: 3.57M]
  ------------------
  982|  1.40M|        return Z_TEXT;
  983|   146M|    for (n = 32; n < LITERALS; n++)
                  ^3.57M                     ^143M
  ------------------
  |  Branch (983:18): [True: 146M, False: 26.8k]
  ------------------
  984|   146M|        if (s->dyn_ltree[n].Freq != 0)
  ------------------
  |  Branch (984:13): [True: 3.54M, False: 143M]
  ------------------
  985|  3.54M|            return Z_TEXT;
  986|       |
  987|       |    /* There are no "block-listed" or "allow-listed" bytes:
  988|       |     * this stream either is empty or has tolerated ("gray-listed") bytes only.
  989|       |     */
  990|  26.8k|    return Z_BINARY;
  991|  3.57M|}
  992|       |
  993|       |/* ===========================================================================
  994|       | * Determine the best encoding for the current block: dynamic trees, static
  995|       | * trees or store, and write out the encoded block.
  996|       | */
  997|       |void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,
  998|  28.2M|                                   ulg stored_len, int last) {
  999|  28.2M|    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
 1000|  28.2M|    int max_blindex = 0;  /* index of last bit length code of non zero freq */
 1001|       |
 1002|       |    /* Build the Huffman trees unless a stored block is forced */
 1003|  28.2M|    if (s->level > 0) {
  ------------------
  |  Branch (1003:9): [True: 28.2M, False: 0]
  ------------------
 1004|       |
 1005|       |        /* Check if the file is binary or text */
 1006|  28.2M|        if (s->strm->data_type == Z_UNKNOWN)
  ------------------
  |  Branch (1006:13): [True: 15.3M, False: 12.9M]
  ------------------
 1007|  15.3M|            s->strm->data_type = detect_data_type(s);
 1008|       |
 1009|       |        /* Construct the literal and distance trees */
 1010|  28.2M|        build_tree(s, (tree_desc *)(&(s->l_desc)));
 1011|  28.2M|        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
 1012|  28.2M|                s->static_len));
 1013|       |
 1014|  28.2M|        build_tree(s, (tree_desc *)(&(s->d_desc)));
 1015|  28.2M|        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
 1016|  28.2M|                s->static_len));
 1017|       |        /* At this point, opt_len and static_len are the total bit lengths of
 1018|       |         * the compressed block data, excluding the tree representations.
 1019|       |         */
 1020|       |
 1021|       |        /* Build the bit length tree for the above two trees, and get the index
 1022|       |         * in bl_order of the last bit length code to send.
 1023|       |         */
 1024|  28.2M|        max_blindex = build_bl_tree(s);
 1025|       |
 1026|       |        /* Determine the best encoding. Compute the block lengths in bytes. */
 1027|  28.2M|        opt_lenb = (s->opt_len + 3 + 7) >> 3;
 1028|  28.2M|        static_lenb = (s->static_len + 3 + 7) >> 3;
 1029|       |
 1030|  28.2M|        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
 1031|  28.2M|                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
 1032|  28.2M|                s->sym_next / 3));
 1033|       |
 1034|  28.2M|#ifndef FORCE_STATIC
 1035|  28.2M|        if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)
                                                     ^14.1k         ^14.1k
  ------------------
  |  Branch (1035:13): [True: 28.2M, False: 14.1k]
  |  Branch (1035:40): [True: 0, False: 14.1k]
  ------------------
 1036|  28.2M|#endif
 1037|  28.2M|            opt_lenb = static_lenb;
 1038|       |
 1039|  28.2M|    } else {
 1040|      0|        Assert(buf != (char*)0, "lost buf");
 1041|      0|        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
 1042|      0|    }
 1043|       |
 1044|       |#ifdef FORCE_STORED
 1045|       |    if (buf != (char*)0) { /* force stored block */
 1046|       |#else
 1047|  28.2M|    if (stored_len + 4 <= opt_lenb && buf != (char*)0) {
                                                    ^18
  ------------------
  |  Branch (1047:9): [True: 18, False: 28.2M]
  |  Branch (1047:39): [True: 18, False: 0]
  ------------------
 1048|       |                       /* 4: two words for the lengths */
 1049|     18|#endif
 1050|       |        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
 1051|       |         * Otherwise we can't have processed more than WSIZE input bytes since
 1052|       |         * the last block flush, because compression would have been
 1053|       |         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
 1054|       |         * transform a block into a stored block.
 1055|       |         */
 1056|     18|        _tr_stored_block(s, buf, stored_len, last);
 1057|       |
 1058|  28.2M|    } else if (static_lenb == opt_lenb) {
  ------------------
  |  Branch (1058:16): [True: 28.2M, False: 14.1k]
  ------------------
 1059|  28.2M|        send_bits(s, (STATIC_TREES<<1) + last, 3);
 1060|  28.2M|        compress_block(s, (const ct_data *)static_ltree,
 1061|  28.2M|                       (const ct_data *)static_dtree);
 1062|       |#ifdef ZLIB_DEBUG
 1063|       |        s->compressed_len += 3 + s->static_len;
 1064|       |#endif
 1065|  28.2M|    } else {
 1066|  14.1k|        send_bits(s, (DYN_TREES<<1) + last, 3);
 1067|  14.1k|        send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,
 1068|  14.1k|                       max_blindex + 1);
 1069|  14.1k|        compress_block(s, (const ct_data *)s->dyn_ltree,
 1070|  14.1k|                       (const ct_data *)s->dyn_dtree);
 1071|       |#ifdef ZLIB_DEBUG
 1072|       |        s->compressed_len += 3 + s->opt_len;
 1073|       |#endif
 1074|  14.1k|    }
 1075|  28.2M|    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
 1076|       |    /* The above check is made mod 2^32, for files larger than 512 MB
 1077|       |     * and uLong implemented on 32 bits.
 1078|       |     */
 1079|  28.2M|    init_block(s);
 1080|       |
 1081|  28.2M|    if (last) {
  ------------------
  |  Branch (1081:9): [True: 15.2M, False: 13.0M]
  ------------------
 1082|  15.2M|        bi_windup(s);
 1083|       |#ifdef ZLIB_DEBUG
 1084|       |        s->compressed_len += 7;  /* align on byte boundary */
 1085|       |#endif
 1086|  15.2M|    }
 1087|  28.2M|    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
 1088|  28.2M|           s->compressed_len - 7*last));
 1089|  28.2M|}
 1090|       |
 1091|       |/* ===========================================================================
 1092|       | * Save the match info and tally the frequency counts. Return true if
 1093|       | * the current block must be flushed.
 1094|       | */
 1095|      0|int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {
 1096|       |#ifdef LIT_MEM
 1097|       |    s->d_buf[s->sym_next] = (ush)dist;
 1098|       |    s->l_buf[s->sym_next++] = (uch)lc;
 1099|       |#else
 1100|      0|    s->sym_buf[s->sym_next++] = (uch)dist;
 1101|      0|    s->sym_buf[s->sym_next++] = (uch)(dist >> 8);
 1102|      0|    s->sym_buf[s->sym_next++] = (uch)lc;
 1103|      0|#endif
 1104|      0|    if (dist == 0) {
  ------------------
  |  Branch (1104:9): [True: 0, False: 0]
  ------------------
 1105|       |        /* lc is the unmatched char */
 1106|      0|        s->dyn_ltree[lc].Freq++;
 1107|      0|    } else {
 1108|      0|        s->matches++;
 1109|       |        /* Here, lc is the match length - MIN_MATCH */
 1110|      0|        dist--;             /* dist = match distance - 1 */
 1111|      0|        Assert((ush)dist < (ush)MAX_DIST(s) &&
 1112|      0|               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
 1113|      0|               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
 1114|       |
 1115|      0|        s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
 1116|      0|        s->dyn_dtree[d_code(dist)].Freq++;
 1117|      0|    }
 1118|      0|    return (s->sym_next == s->sym_end);
 1119|      0|}

/home/minseo/alfha/targets/zlib/target/zutil.c:
    1|       |/* zutil.c -- target dependent utility functions for the compression library
    2|       | * Copyright (C) 1995-2017 Jean-loup Gailly
    3|       | * For conditions of distribution and use, see copyright notice in zlib.h
    4|       | */
    5|       |
    6|       |/* @(#) $Id$ */
    7|       |
    8|       |#include "zutil.h"
    9|       |#ifndef Z_SOLO
   10|       |#  include "gzguts.h"
   11|       |#endif
   12|       |
   13|       |z_const char * const z_errmsg[10] = {
   14|       |    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
   15|       |    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
   16|       |    (z_const char *)"",                    /* Z_OK              0  */
   17|       |    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
   18|       |    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
   19|       |    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
   20|       |    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
   21|       |    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
   22|       |    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
   23|       |    (z_const char *)""
   24|       |};
   25|       |
   26|       |
   27|      0|const char * ZEXPORT zlibVersion(void) {
   28|      0|    return ZLIB_VERSION;
   29|      0|}
   30|       |
   31|      0|uLong ZEXPORT zlibCompileFlags(void) {
   32|      0|    uLong flags;
   33|       |
   34|      0|    flags = 0;
   35|      0|    switch ((int)(sizeof(uInt))) {
   36|      0|    case 2:     break;
  ------------------
  |  Branch (36:5): [True: 0, False: 0]
  ------------------
   37|      0|    case 4:     flags += 1;     break;
  ------------------
  |  Branch (37:5): [True: 0, False: 0]
  ------------------
   38|      0|    case 8:     flags += 2;     break;
  ------------------
  |  Branch (38:5): [True: 0, False: 0]
  ------------------
   39|      0|    default:    flags += 3;
  ------------------
  |  Branch (39:5): [True: 0, False: 0]
  ------------------
   40|      0|    }
   41|      0|    switch ((int)(sizeof(uLong))) {
   42|      0|    case 2:     break;
  ------------------
  |  Branch (42:5): [True: 0, False: 0]
  ------------------
   43|      0|    case 4:     flags += 1 << 2;        break;
  ------------------
  |  Branch (43:5): [True: 0, False: 0]
  ------------------
   44|      0|    case 8:     flags += 2 << 2;        break;
  ------------------
  |  Branch (44:5): [True: 0, False: 0]
  ------------------
   45|      0|    default:    flags += 3 << 2;
  ------------------
  |  Branch (45:5): [True: 0, False: 0]
  ------------------
   46|      0|    }
   47|      0|    switch ((int)(sizeof(voidpf))) {
   48|      0|    case 2:     break;
  ------------------
  |  Branch (48:5): [True: 0, False: 0]
  ------------------
   49|      0|    case 4:     flags += 1 << 4;        break;
  ------------------
  |  Branch (49:5): [True: 0, False: 0]
  ------------------
   50|      0|    case 8:     flags += 2 << 4;        break;
  ------------------
  |  Branch (50:5): [True: 0, False: 0]
  ------------------
   51|      0|    default:    flags += 3 << 4;
  ------------------
  |  Branch (51:5): [True: 0, False: 0]
  ------------------
   52|      0|    }
   53|      0|    switch ((int)(sizeof(z_off_t))) {
   54|      0|    case 2:     break;
  ------------------
  |  Branch (54:5): [True: 0, False: 0]
  ------------------
   55|      0|    case 4:     flags += 1 << 6;        break;
  ------------------
  |  Branch (55:5): [True: 0, False: 0]
  ------------------
   56|      0|    case 8:     flags += 2 << 6;        break;
  ------------------
  |  Branch (56:5): [True: 0, False: 0]
  ------------------
   57|      0|    default:    flags += 3 << 6;
  ------------------
  |  Branch (57:5): [True: 0, False: 0]
  ------------------
   58|      0|    }
   59|       |#ifdef ZLIB_DEBUG
   60|       |    flags += 1 << 8;
   61|       |#endif
   62|       |    /*
   63|       |#if defined(ASMV) || defined(ASMINF)
   64|       |    flags += 1 << 9;
   65|       |#endif
   66|       |     */
   67|       |#ifdef ZLIB_WINAPI
   68|       |    flags += 1 << 10;
   69|       |#endif
   70|       |#ifdef BUILDFIXED
   71|       |    flags += 1 << 12;
   72|       |#endif
   73|       |#ifdef DYNAMIC_CRC_TABLE
   74|       |    flags += 1 << 13;
   75|       |#endif
   76|       |#ifdef NO_GZCOMPRESS
   77|       |    flags += 1L << 16;
   78|       |#endif
   79|       |#ifdef NO_GZIP
   80|       |    flags += 1L << 17;
   81|       |#endif
   82|       |#ifdef PKZIP_BUG_WORKAROUND
   83|       |    flags += 1L << 20;
   84|       |#endif
   85|       |#ifdef FASTEST
   86|       |    flags += 1L << 21;
   87|       |#endif
   88|      0|#if defined(STDC) || defined(Z_HAVE_STDARG_H)
   89|       |#  ifdef NO_vsnprintf
   90|       |    flags += 1L << 25;
   91|       |#    ifdef HAS_vsprintf_void
   92|       |    flags += 1L << 26;
   93|       |#    endif
   94|       |#  else
   95|       |#    ifdef HAS_vsnprintf_void
   96|       |    flags += 1L << 26;
   97|       |#    endif
   98|      0|#  endif
   99|       |#else
  100|       |    flags += 1L << 24;
  101|       |#  ifdef NO_snprintf
  102|       |    flags += 1L << 25;
  103|       |#    ifdef HAS_sprintf_void
  104|       |    flags += 1L << 26;
  105|       |#    endif
  106|       |#  else
  107|       |#    ifdef HAS_snprintf_void
  108|       |    flags += 1L << 26;
  109|       |#    endif
  110|       |#  endif
  111|       |#endif
  112|      0|    return flags;
  113|      0|}
  114|       |
  115|       |#ifdef ZLIB_DEBUG
  116|       |#include <stdlib.h>
  117|       |#  ifndef verbose
  118|       |#    define verbose 0
  119|       |#  endif
  120|       |int ZLIB_INTERNAL z_verbose = verbose;
  121|       |
  122|       |void ZLIB_INTERNAL z_error(char *m) {
  123|       |    fprintf(stderr, "%s\n", m);
  124|       |    exit(1);
  125|       |}
  126|       |#endif
  127|       |
  128|       |/* exported to allow conversion of error code to string for compress() and
  129|       | * uncompress()
  130|       | */
  131|      0|const char * ZEXPORT zError(int err) {
  132|      0|    return ERR_MSG(err);
  133|      0|}
  134|       |
  135|       |#if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
  136|       |    /* The older Microsoft C Run-Time Library for Windows CE doesn't have
  137|       |     * errno.  We define it as a global variable to simplify porting.
  138|       |     * Its value is always 0 and should not be used.
  139|       |     */
  140|       |    int errno = 0;
  141|       |#endif
  142|       |
  143|       |#ifndef HAVE_MEMCPY
  144|       |
  145|       |void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len) {
  146|       |    if (len == 0) return;
  147|       |    do {
  148|       |        *dest++ = *source++; /* ??? to be unrolled */
  149|       |    } while (--len != 0);
  150|       |}
  151|       |
  152|       |int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len) {
  153|       |    uInt j;
  154|       |
  155|       |    for (j = 0; j < len; j++) {
  156|       |        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
  157|       |    }
  158|       |    return 0;
  159|       |}
  160|       |
  161|       |void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len) {
  162|       |    if (len == 0) return;
  163|       |    do {
  164|       |        *dest++ = 0;  /* ??? to be unrolled */
  165|       |    } while (--len != 0);
  166|       |}
  167|       |#endif
  168|       |
  169|       |#ifndef Z_SOLO
  170|       |
  171|       |#ifdef SYS16BIT
  172|       |
  173|       |#ifdef __TURBOC__
  174|       |/* Turbo C in 16-bit mode */
  175|       |
  176|       |#  define MY_ZCALLOC
  177|       |
  178|       |/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
  179|       | * and farmalloc(64K) returns a pointer with an offset of 8, so we
  180|       | * must fix the pointer. Warning: the pointer must be put back to its
  181|       | * original form in order to free it, use zcfree().
  182|       | */
  183|       |
  184|       |#define MAX_PTR 10
  185|       |/* 10*64K = 640K */
  186|       |
  187|       |local int next_ptr = 0;
  188|       |
  189|       |typedef struct ptr_table_s {
  190|       |    voidpf org_ptr;
  191|       |    voidpf new_ptr;
  192|       |} ptr_table;
  193|       |
  194|       |local ptr_table table[MAX_PTR];
  195|       |/* This table is used to remember the original form of pointers
  196|       | * to large buffers (64K). Such pointers are normalized with a zero offset.
  197|       | * Since MSDOS is not a preemptive multitasking OS, this table is not
  198|       | * protected from concurrent access. This hack doesn't work anyway on
  199|       | * a protected system like OS/2. Use Microsoft C instead.
  200|       | */
  201|       |
  202|       |voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {
  203|       |    voidpf buf;
  204|       |    ulg bsize = (ulg)items*size;
  205|       |
  206|       |    (void)opaque;
  207|       |
  208|       |    /* If we allocate less than 65520 bytes, we assume that farmalloc
  209|       |     * will return a usable pointer which doesn't have to be normalized.
  210|       |     */
  211|       |    if (bsize < 65520L) {
  212|       |        buf = farmalloc(bsize);
  213|       |        if (*(ush*)&buf != 0) return buf;
  214|       |    } else {
  215|       |        buf = farmalloc(bsize + 16L);
  216|       |    }
  217|       |    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
  218|       |    table[next_ptr].org_ptr = buf;
  219|       |
  220|       |    /* Normalize the pointer to seg:0 */
  221|       |    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
  222|       |    *(ush*)&buf = 0;
  223|       |    table[next_ptr++].new_ptr = buf;
  224|       |    return buf;
  225|       |}
  226|       |
  227|       |void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {
  228|       |    int n;
  229|       |
  230|       |    (void)opaque;
  231|       |
  232|       |    if (*(ush*)&ptr != 0) { /* object < 64K */
  233|       |        farfree(ptr);
  234|       |        return;
  235|       |    }
  236|       |    /* Find the original pointer */
  237|       |    for (n = 0; n < next_ptr; n++) {
  238|       |        if (ptr != table[n].new_ptr) continue;
  239|       |
  240|       |        farfree(table[n].org_ptr);
  241|       |        while (++n < next_ptr) {
  242|       |            table[n-1] = table[n];
  243|       |        }
  244|       |        next_ptr--;
  245|       |        return;
  246|       |    }
  247|       |    Assert(0, "zcfree: ptr not found");
  248|       |}
  249|       |
  250|       |#endif /* __TURBOC__ */
  251|       |
  252|       |
  253|       |#ifdef M_I86
  254|       |/* Microsoft C in 16-bit mode */
  255|       |
  256|       |#  define MY_ZCALLOC
  257|       |
  258|       |#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
  259|       |#  define _halloc  halloc
  260|       |#  define _hfree   hfree
  261|       |#endif
  262|       |
  263|       |voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size) {
  264|       |    (void)opaque;
  265|       |    return _halloc((long)items, size);
  266|       |}
  267|       |
  268|       |void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {
  269|       |    (void)opaque;
  270|       |    _hfree(ptr);
  271|       |}
  272|       |
  273|       |#endif /* M_I86 */
  274|       |
  275|       |#endif /* SYS16BIT */
  276|       |
  277|       |
  278|       |#ifndef MY_ZCALLOC /* Any system without a special alloc function */
  279|       |
  280|       |#ifndef STDC
  281|       |extern voidp malloc(uInt size);
  282|       |extern voidp calloc(uInt items, uInt size);
  283|       |extern void free(voidpf ptr);
  284|       |#endif
  285|       |
  286|  7.34G|voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {
  287|  7.34G|    (void)opaque;
  288|  7.34G|    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
  ------------------
  |  Branch (288:12): [Folded - Ignored]
  ------------------
  289|  7.34G|                              (voidpf)calloc(items, size);
                                            ^0
  290|  7.34G|}
  291|       |
  292|  7.34G|void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {
  293|  7.34G|    (void)opaque;
  294|  7.34G|    free(ptr);
  295|  7.34G|}
  296|       |
  297|       |#endif /* MY_ZCALLOC */
  298|       |
  299|       |#endif /* !Z_SOLO */

